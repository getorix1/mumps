// ==============================================================
//#+ This module generated by Mumps Compiler 
//#+ Tue Jun 11 13:58:02 2024
//#+ Portions of this code are part of the Mumps Compiler
//#+ 
//#+ Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 
//#+ 2010, 2017, 2020, 2022, 2024 by Kevin C. O'Kane  
//#+ 
//#+ Kevin C. O'Kane, Ph.D.
//#+ Professor Emeritus
//#+ Computer Science Department
//#+ University of Northern Iowa
//#+ Cedar Falls, IA 50614-0507
//#+ kc.okane@gmail.com
//#+ okane@uni.edu
//#+ https://threadsafebooks.com
//#+ https://www.cs.uni.edu/~okane
//#+ -----------------------------------
//#+ 
//#+ Consult individual modules for copyright details
//#+ The runtime libraries are covered by the following license:
//#+  
//#+ This library is free software; you can redistribute it and/or
//#+ modify it under the terms of the GNU Lesser General Public
//#+ License as published by the Free Software Foundation; either
//#+ version 2.1 of the License, or (at your option) any later version.
//#+ 
//#+ This library is distributed in the hope that it will be useful,
//#+ but WITHOUT ANY WARRANTY; without even the implied warranty of
//#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//#+ Lesser General Public License for more details.
//#+ 
//#+ You should have received a copy of the GNU Lesser General Public
//#+ License along with this library; if not, write to the Free Software
//#+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#+ 
//#+ This code is unverified - use at your own risk 
//#+==============================================================

#undef _MDH_
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <mumpsc/inline.h>
#include <mumpsc/defines.h>
#include <mumpsc/strmax.h>
#include <mumpsc/libmpscpp.h>
#include <mumpsc/sym.h>
#include <mumpsc/builtin.h>
#include <mumpsc/compiler.h>
#define FORPARM STR_MAX  /* Size of For loop parameter */
#define CSTR (char *)
#define UNS unsigned char *
#define uns unsigned char *
#define CCHR const char *
#include <mumpsc/keyfix.h>
#include <mumpsc/globalOrder.h>
#include <mumpsc/stateVector.h>
int (*__label_lookup)(char *);
const char * (*__text_function)(int);
void fcn(MSV *);
void zfcn(unsigned char *, unsigned char *, struct MSV *); /* z functions */
char * sym_(int, unsigned char *, unsigned char *, struct MSV *); /* symbol table */
char * makeLock(char *, char *, char *, char, char *); /* global array lock service */
char * cleanLocks(char *); /* global array lock service */
char * releaseLock(char *, char *, char *); /* global array lock service */
char * eraseLocks(char *); /* global array lock service */
void add(const char *a,const char *b,char *c); /* math function */
void sub(const char *a,const char *b,char *c); /* math function */
void mult(const char *a,const char *b,char *c); /* math function */
void divx(const char *a,const char *b,char *c); /* math function */
void divi(const char *a,const char *b,char *c); /* math function */
void _fnumber(unsigned char *,unsigned char *,
       unsigned char *,unsigned char *, MSV *); /* math function */
int DBSem = 0; /* deadlock prevention */

static inline int floatstring(const char * p) { 
 int f=0;  
 for (; *p!=0; p++) {  
	 if (    isdigit(*p) || 
	 	*p == '-' ||  
		*p == '+' ) continue;  
 	if (    *p=='.' ||  
		tolower(*p)=='e' ) { 
		f=1;  
		continue;  
		} 
	return 0; 
	}  
 return f;  
 } 
 
inline int numcomp2(unsigned char *aa) { 
 if (floatstring((char *) aa)) return (atof( (char *) aa) != 0.0);  
 return atoi((char *) aa);  
 }

inline char * strxcat(char * a, char *b)  
{ while (*a) a++; while( (*(a) = *(b)) ) { a++; b++; } return a; }

inline char * strcatz(char * out, char *in)  
{ while (*out) out++; while (*(out) = *(in)) { out++; in++; } *(out++) = '';  
*out = 0; return (char *) out; } 

void SyncClock() {
    DBSem = 1;
    }

unsigned int set_alarm (unsigned int seconds) {
    struct itimerval old, xnew;
    xnew.it_interval.tv_usec = 0;
    xnew.it_interval.tv_sec = 0 ; // interval between alarms
    xnew.it_value.tv_usec = 0;
    xnew.it_value.tv_sec = (long int) 0;
    if (setitimer (ITIMER_REAL, &xnew, &old) < 0)
        return 0;
    else
        return old.it_value.tv_sec;
    }

#include <mumpsc/global.h>  /* Global array definitions */
  /* Interface to Mglobal(): */
  /* g = command */
  /* key = key sought or stored */
  /* bd = value returned or stored */
  /* svPtr = address of state vector */
#ifndef SUB
#include <mumpsc/fcns.h>  /* System support functions */
#include <mumpsc/sysfunc.h>  /* Many common global variables */
#endif

// !/usr/bin/mumps

//================================================================================= 
//  zmain 
//================================================================================= 

int main(int argc, char *argv[]) {

//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#+ Intermediate temporary variables used during execution of string expressions
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

char * catx; // intermediate concat ptr
char *_ftmp = new char[STR_MAX]; /* intermediate temp */
/*** Temporary variables */
char for1_incr[FORPARM], for1_lim[FORPARM], for1_init[FORPARM];
int for1F; int for1T; long for1; double for1D;
char for2_incr[FORPARM], for2_lim[FORPARM], for2_init[FORPARM];
int for2F; int for2T; long for2; double for2D;
jmp_buf for0J;
jmp_buf for1J;
jmp_buf for2J;
jmp_buf for3J;
jmp_buf Efor0J;
int tpx0;
jmp_buf Efor1J;
int tpx1;
jmp_buf Efor2J;
int tpx2;
unsigned char *tmp0 = new unsigned char[STR_MAX];
unsigned char *tmp1 = new unsigned char[STR_MAX];
unsigned char *tmp2 = new unsigned char[STR_MAX];
unsigned char *tmp3 = new unsigned char[STR_MAX];
unsigned char *_dummy = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *atmp =new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *xgtmp = new unsigned char [STR_MAX]; /* temporary variable */
unsigned char *gtmpL = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *tmp = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *gtmp = new unsigned char [2*STR_MAX]; /* temporary variable */
int _label_lookup(char *); /* resolution of labels */
const char * _text_function(int);
static unsigned char _ReturnVal[STR_MAX]; /* function returns */
int _ArgCount=0; /* Nbr of args to extrinsic */
long _i,_jj,_j,_k,_new;
int _SymPush=0,f=0;
int g=0;
jmp_buf _doStack[128]; /* <do> return stack mechanism */
short   _doStackN[128]={0}; /* <do> return stack mechanism */
static int     _doStx=0; /* <do> return stack mechanism */
char _Refs[10][32];
int _Refsx=0;

if (svPtr == NULL) svPtr = AllocSV();

_SymPush=0; // zap pushed tables 

svPtr->in_file[5]=stdin; // console default/
svPtr->out_file[5]=stdout; // console default

strcpy(svPtr->UDAT,"data.dat");
strcpy(svPtr->UKEY,"key.dat");

if ( 0) { // no alarm if slice is zero
	signal(SIGALRM, SyncClock);
	set_alarm(1);
	}

__label_lookup = _label_lookup;
__text_function = _text_function;

$SymPut("%",argv[0]); 

if (argc > 0) { 
	for (int i = 0; i < argc; i++) { 
		char t[STR_MAX]; 
		sprintf(t,"%%%d", i); 
		$SymPut(t, argv[i]); 
		} 
	} 

try { 

//  watch for null $p(line2," ",1)

//================================================================================= 
svPtr->LineNumber=7; //  write !,"Results for: ",%1,!! 
//================================================================================= 

//--------------
//       Write
//--------------

	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // m1944 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"Results for: ");
	if (sym_(SYMGET, (UNS) "%1", (UNS) tmp0, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "%1"); // not found
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 

//================================================================================= 
svPtr->LineNumber=8; //  for  do 
//================================================================================= 

//--------------
//       For
//--------------

	while(1) {  /* Argumentless FOR */

//--------------
//       Do
//--------------

		tpx0 = svPtr->tpx; 
		if ( (_i = setjmp(Efor0J)) == 0) goto Do_Block_Entry0; //else continue 
		else if (_i == 100) goto Do_Block_Bypass0; // IF_flg m1402
	} 
	goto Do_Block_Bypass0; // C3551 bypass indented group

Do_Block_Entry0:; // Enter Do Block

do { /* dotted indent entry */

//================================================================================= 
svPtr->LineNumber=9; //  . read line 
//================================================================================= 

//--------------
//       Read
//--------------

	if (svPtr->in_file[svPtr->io] == NULL) 
		ErrorMessage("Read from input file", svPtr->LineNumber); 
	svPtr->tpx = getstr1(svPtr->in_file[svPtr->io], &gtmp); // Read string into gtmp
	if (svPtr->tpx >= 0) svPtr->tpx = 1; else svPtr->tpx = 0; // Set $Test
	sym_(SYMSTORE, (UNS) "line", (UNS) gtmp, svPtr); // Store result s274 

//================================================================================= 
svPtr->LineNumber=10; //  . if '$t break 
//================================================================================= 

//--------------
//       If
//--------------

	if (svPtr->tpx) tmp0[0]='1'; /* $test */
	else tmp0[0]='0';
	tmp0[1]='\0';
	if (numcomp1( (UNS) tmp0, 0) == 0) 
		strmove( (UNS) tmp1, (UNS) "1");
	else strmove( (UNS) tmp1, (UNS) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp2((UNS) tmp1 )) { // Test if true 
	svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

     svPtr->tpx=tpx0; // break code: restore $test
  longjmp(Efor0J,100); 
	} 

//================================================================================= 
svPtr->LineNumber=11; //  . write $p(line,"###",1),! 
//================================================================================= 

//--------------
//       Write
//--------------

	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // m1944 
	if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
	_piece((UNS) tmp1, 
		(UNS) tmp0,(UNS) "###",(UNS) "1", (UNS) "-1", 
		0, (UNS) "", svPtr); // p1136
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp1);
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 

//================================================================================= 
svPtr->LineNumber=12; //  . set line2=$piece(line,"###",2) 
//================================================================================= 

//--------------
//       Set
//--------------

	if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
	_piece((UNS) tmp2, 
		(UNS) tmp1,(UNS) "###",(UNS) "2", (UNS) "-1", 
		0, (UNS) "", svPtr); // p1136
	sym_(SYMSTORE, (UNS) "line2", (UNS) tmp2, svPtr); // Store result s274 

//================================================================================= 
svPtr->LineNumber=13; //  . write ?10 
//================================================================================= 

//--------------
//       Write
//--------------

	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // m1944 
	 _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io], 
"10", svPtr->out_file[svPtr->io]); // tab operator

//================================================================================= 
svPtr->LineNumber=14; //  . for i=2:1 do 
//================================================================================= 

//--------------
//       For
//--------------

	strcpy(for2_lim, "");
//	m2525
	strmove((UNS) for2_init, (UNS) "2"); // init value m2534
	strmove( (UNS) for2_incr, (UNS) "1"); // inc/dec m2575

	if (strchr((char *) for2_incr, '.')) { // inc/dec is float
		for2D = atof(for2_incr); // inc/dec value
		for2F = for2D < 0.0 ? 1 : 0; // incr or decr?
		}
	else { // inc/dec is integer
		for2 = atol(for2_incr); // inc/dec value
		for2F = for2 < 0 ? 1 : 0; // incr or decr?
		} 

	for ( sym_(SYMSTORE, (UNS) "i", (UNS) for2_init, svPtr); // init 2618

		1;  // limit expression - no limit

		add( sym_(11, (UNS) "i", _dummy, svPtr), // inc/dec loop var
			for2_incr, (char *) _dummy),
		sym_(SYMSTORE, (UNS) "i", (UNS) _dummy, svPtr) ) // store rslt

		if ((_i = setjmp(for2J)) == 0) goto For2; // else continue

	else if (_i == 100) goto For2Exit; // f273

	goto For2Exit; // bypass block 

For2: // for loop body entry point B

	do { // for loop body
		svPtr->LineNumber = 14; 

//--------------
//       Do
//--------------

		tpx1 = svPtr->tpx; 
		if ( (_i = setjmp(Efor1J)) == 0) goto Do_Block_Entry1; //else continue 
		else if (_i == 100) goto Do_Block_Bypass1; // IF_flg m1402
	} while (0); longjmp(for2J, _i); // FOR loop 1 close 

For2Exit: ; // exit for loop 

	goto Do_Block_Bypass1; // C3551 bypass indented group

Do_Block_Entry1:; // Enter Do Block

do { /* dotted indent entry */

//================================================================================= 
svPtr->LineNumber=15; //  .. set w=$p(line2," ",i) 
//================================================================================= 

//--------------
//       Set
//--------------

	if (sym_(SYMGET, (UNS) "line2", (UNS) tmp1, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "line2"); // not found
	if (sym_(SYMGET, (UNS) "i", (UNS) tmp2, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "i"); // not found
	_piece((UNS) tmp3, 
		(UNS) tmp1,(UNS) " ",(UNS) tmp2, (UNS) "-1", 
		0, (UNS) "", svPtr); // p1136
	sym_(SYMSTORE, (UNS) "w", (UNS) tmp3, svPtr); // Store result s274 

//================================================================================= 
svPtr->LineNumber=16; //  .. if w="" break 
//================================================================================= 

//--------------
//       If
//--------------

	if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
	if (strcmp((const char *) tmp0,(const char *) "")==0) 
	strmove( (UNS) tmp1, (UNS) "1");
	else strmove( (UNS) tmp1, (UNS) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp2((UNS) tmp1 )) { // Test if true 
	svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

     svPtr->tpx=tpx1; // break code: restore $test
  longjmp(Efor1J,100); 
	} 

//================================================================================= 
svPtr->LineNumber=17; //  .. write w," " 
//================================================================================= 

//--------------
//       Write
//--------------

	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // m1944 
	if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value 
		VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");

//================================================================================= 
svPtr->LineNumber=18; //  .. if $x>60 write ?10 
//================================================================================= 

//--------------
//       If
//--------------

	sprintf((char *) tmp0,"%d",svPtr->hor[svPtr->io]); /* $x */
	if (numcomp1((UNS) tmp0, 60) > 0) strmove((UNS) tmp1, (UNS) "1");
	else strmove((UNS) tmp1, (UNS) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp2((UNS) tmp1 )) { // Test if true 
	svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // m1944 
	 _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io], 
"10", svPtr->out_file[svPtr->io]); // tab operator
	} 
	} while (0); /* dotted un-indent 1 */
	longjmp(Efor1J,99); /* return */

Do_Block_Bypass1: ; // D3607 

//================================================================================= 
svPtr->LineNumber=19; //  . write !! 
//================================================================================= 

//--------------
//       Write
//--------------

	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // m1944 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	} while (0);   // dotted un-indent 0
	longjmp(Efor0J,99);    // return 

Do_Block_Bypass0: ; //A541 

//=================================================================================
_epilogue: tmp0[0]=0; tmp1[0]=0;  /*  Function Epilogue */
	Mltoa(getpid(),atmp);
	if (svPtr->LockDone) cleanLocks((char *) atmp);
	Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */

} // end of try block 

catch(...) { 
     if (GlobalExceptionCode == INPUT_ERROR) cout << "Input Error" << endl;
     else if (GlobalExceptionCode == INPUT_LENGTH) cout << "Input Length Error" << endl;
     else if (GlobalExceptionCode == SYMTAB_ERROR) cout << "Symbol Table Error" << endl;
     else if (GlobalExceptionCode == GLOBAL_NOT_FOUND) cout << "Global Not Found Error" << endl;
     else if (GlobalExceptionCode == INTERPRETER_ERROR) cout << "Interprerer Error" << endl;
     else if (GlobalExceptionCode == INVALID_CONVERSION) cout << "Invalid Conversion Error" << endl;
     else if (GlobalExceptionCode == DATA_RANGE_ERROR) cout << "Data Range Error" << endl;
     else if (GlobalExceptionCode == NUMERIC_RANGE) cout << "Numeric Range Error" << endl;
     else if (GlobalExceptionCode == UNSPECIFIED) cout << "Unspecified Error" << endl;
	cout << "Uncaught error in or near line " 
	<< svPtr->LineNumber << endl;
	Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */
	} 

return EXIT_SUCCESS; }  /* Terminate */
//=================================================================================


int _label_lookup(char *label) { return -1; }
const char * _text_function(int disp) { return NULL; }

