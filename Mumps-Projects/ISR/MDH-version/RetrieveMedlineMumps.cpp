// ==============================================================
//#+ This module generated by Mumps Compiler
//#+ Tue Jun 11 13:57:56 2024
//#+ Portions of this code are part of the Mumps Compiler
//#+
//#+ Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005,
//#+ 2010, 2017, 2020, 2022, 2024 by Kevin C. O'Kane
//#+
//#+ Kevin C. O'Kane, Ph.D.
//#+ Professor Emeritus
//#+ Computer Science Department
//#+ University of Northern Iowa
//#+ Cedar Falls, IA 50614-0507
//#+ kc.okane@gmail.com
//#+ okane@uni.edu
//#+ https://threadsafebooks.com
//#+ https://www.cs.uni.edu/~okane
//#+ -----------------------------------
//#+
//#+ Consult individual modules for copyright details
//#+ The runtime libraries are covered by the following license:
//#+
//#+ This library is free software; you can redistribute it and/or
//#+ modify it under the terms of the GNU Lesser General Public
//#+ License as published by the Free Software Foundation; either
//#+ version 2.1 of the License, or (at your option) any later version.
//#+
//#+ This library is distributed in the hope that it will be useful,
//#+ but WITHOUT ANY WARRANTY; without even the implied warranty of
//#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//#+ Lesser General Public License for more details.
//#+
//#+ You should have received a copy of the GNU Lesser General Public
//#+ License along with this library; if not, write to the Free Software
//#+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#+
//#+ This code is unverified - use at your own risk
//#+==============================================================

#undef _MDH_
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <mumpsc/inline.h>
#include <mumpsc/defines.h>
#include <mumpsc/strmax.h>
#include <mumpsc/libmpscpp.h>
#include <mumpsc/sym.h>
#include <mumpsc/builtin.h>
#include <mumpsc/compiler.h>
#define FORPARM STR_MAX  /* Size of For loop parameter */
#define CSTR (char *)
#define UNS unsigned char *
#define uns unsigned char *
#define CCHR const char *
#include <mumpsc/keyfix.h>
#include <mumpsc/globalOrder.h>
#include <mumpsc/stateVector.h>
int (*__label_lookup)(char *);
const char * (*__text_function)(int);
void fcn(MSV *);
void zfcn(unsigned char *, unsigned char *, struct MSV *); /* z functions */
char * sym_(int, unsigned char *, unsigned char *, struct MSV *); /* symbol table */
char * makeLock(char *, char *, char *, char, char *); /* global array lock service */
char * cleanLocks(char *); /* global array lock service */
char * releaseLock(char *, char *, char *); /* global array lock service */
char * eraseLocks(char *); /* global array lock service */
void add(const char *a,const char *b,char *c); /* math function */
void sub(const char *a,const char *b,char *c); /* math function */
void mult(const char *a,const char *b,char *c); /* math function */
void divx(const char *a,const char *b,char *c); /* math function */
void divi(const char *a,const char *b,char *c); /* math function */
void _fnumber(unsigned char *,unsigned char *,
              unsigned char *,unsigned char *, MSV *); /* math function */
int DBSem = 0; /* deadlock prevention */

static inline int floatstring(const char * p) {
    int f=0;
    for (; *p!=0; p++) {
        if (    isdigit(*p) ||
                *p == '-' ||
                *p == '+' ) continue;
        if (    *p=='.' ||
                tolower(*p)=='e' ) {
            f=1;
            continue;
            }
        return 0;
        }
    return f;
    }

inline int numcomp2(unsigned char *aa) {
    if (floatstring((char *) aa)) return (atof( (char *) aa) != 0.0);
    return atoi((char *) aa);
    }

inline char * strxcat(char * a, char *b) {
    while (*a) a++;
    while( (*(a) = *(b)) ) {
        a++;
        b++;
        }
    return a;
    }

inline char * strcatz(char * out, char *in) {
    while (*out) out++;
    while (*(out) = *(in)) {
        out++;
        in++;
        }
    *(out++) = '';
    *out = 0;
    return (char *) out;
    }

void SyncClock() {
    DBSem = 1;
    }

unsigned int set_alarm (unsigned int seconds) {
    struct itimerval old, xnew;
    xnew.it_interval.tv_usec = 0;
    xnew.it_interval.tv_sec = 0 ; // interval between alarms
    xnew.it_value.tv_usec = 0;
    xnew.it_value.tv_sec = (long int) 0;
    if (setitimer (ITIMER_REAL, &xnew, &old) < 0)
        return 0;
    else
        return old.it_value.tv_sec;
    }

#include <mumpsc/global.h>  /* Global array definitions */
/* Interface to Mglobal(): */
/* g = command */
/* key = key sought or stored */
/* bd = value returned or stored */
/* svPtr = address of state vector */
#ifndef SUB
#include <mumpsc/fcns.h>  /* System support functions */
#include <mumpsc/sysfunc.h>  /* Many common global variables */
#endif

// !/usr/bin/mumps

//  ~/Medline2012/medlineRetrieve.mps

//  Copyright 2014, 2022 Kevin C. O'Kane

//  August 26, 2022

//=================================================================================
//  zmain
//=================================================================================

int main(int argc, char *argv[]) {

//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#+ Intermediate temporary variables used during execution of string expressions
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    char * catx; // intermediate concat ptr
    char *_ftmp = new char[STR_MAX]; /* intermediate temp */
    /*** Temporary variables */
    char for1_incr[FORPARM], for1_lim[FORPARM], for1_init[FORPARM];
    int for1F;
    int for1T;
    long for1;
    double for1D;
    char for2_incr[FORPARM], for2_lim[FORPARM], for2_init[FORPARM];
    int for2F;
    int for2T;
    long for2;
    double for2D;
    char for3_incr[FORPARM], for3_lim[FORPARM], for3_init[FORPARM];
    int for3F;
    int for3T;
    long for3;
    double for3D;
    char for4_incr[FORPARM], for4_lim[FORPARM], for4_init[FORPARM];
    int for4F;
    int for4T;
    long for4;
    double for4D;
    char for5_incr[FORPARM], for5_lim[FORPARM], for5_init[FORPARM];
    int for5F;
    int for5T;
    long for5;
    double for5D;
    char for6_incr[FORPARM], for6_lim[FORPARM], for6_init[FORPARM];
    int for6F;
    int for6T;
    long for6;
    double for6D;
    char for7_incr[FORPARM], for7_lim[FORPARM], for7_init[FORPARM];
    int for7F;
    int for7T;
    long for7;
    double for7D;
    char for8_incr[FORPARM], for8_lim[FORPARM], for8_init[FORPARM];
    int for8F;
    int for8T;
    long for8;
    double for8D;
    char for9_incr[FORPARM], for9_lim[FORPARM], for9_init[FORPARM];
    int for9F;
    int for9T;
    long for9;
    double for9D;
    char for10_incr[FORPARM], for10_lim[FORPARM], for10_init[FORPARM];
    int for10F;
    int for10T;
    long for10;
    double for10D;
    char for11_incr[FORPARM], for11_lim[FORPARM], for11_init[FORPARM];
    int for11F;
    int for11T;
    long for11;
    double for11D;
    char for12_incr[FORPARM], for12_lim[FORPARM], for12_init[FORPARM];
    int for12F;
    int for12T;
    long for12;
    double for12D;
    char for13_incr[FORPARM], for13_lim[FORPARM], for13_init[FORPARM];
    int for13F;
    int for13T;
    long for13;
    double for13D;
    char for14_incr[FORPARM], for14_lim[FORPARM], for14_init[FORPARM];
    int for14F;
    int for14T;
    long for14;
    double for14D;
    char for15_incr[FORPARM], for15_lim[FORPARM], for15_init[FORPARM];
    int for15F;
    int for15T;
    long for15;
    double for15D;
    char for16_incr[FORPARM], for16_lim[FORPARM], for16_init[FORPARM];
    int for16F;
    int for16T;
    long for16;
    double for16D;
    char for17_incr[FORPARM], for17_lim[FORPARM], for17_init[FORPARM];
    int for17F;
    int for17T;
    long for17;
    double for17D;
    char for18_incr[FORPARM], for18_lim[FORPARM], for18_init[FORPARM];
    int for18F;
    int for18T;
    long for18;
    double for18D;
    char for19_incr[FORPARM], for19_lim[FORPARM], for19_init[FORPARM];
    int for19F;
    int for19T;
    long for19;
    double for19D;
    char for20_incr[FORPARM], for20_lim[FORPARM], for20_init[FORPARM];
    int for20F;
    int for20T;
    long for20;
    double for20D;
    char for21_incr[FORPARM], for21_lim[FORPARM], for21_init[FORPARM];
    int for21F;
    int for21T;
    long for21;
    double for21D;
    jmp_buf for0J;
    jmp_buf for1J;
    jmp_buf for2J;
    jmp_buf for3J;
    jmp_buf for4J;
    jmp_buf for5J;
    jmp_buf for6J;
    jmp_buf for7J;
    jmp_buf for8J;
    jmp_buf for9J;
    jmp_buf for10J;
    jmp_buf for11J;
    jmp_buf for12J;
    jmp_buf for13J;
    jmp_buf for14J;
    jmp_buf for15J;
    jmp_buf for16J;
    jmp_buf for17J;
    jmp_buf for18J;
    jmp_buf for19J;
    jmp_buf for20J;
    jmp_buf for21J;
    char *__Arg0 = new char[STR_MAX];
    jmp_buf Efor0J;
    int tpx0;
    jmp_buf Efor1J;
    int tpx1;
    jmp_buf Efor2J;
    int tpx2;
    jmp_buf Efor3J;
    int tpx3;
    jmp_buf Efor4J;
    int tpx4;
    jmp_buf Efor5J;
    int tpx5;
    jmp_buf Efor6J;
    int tpx6;
    jmp_buf Efor7J;
    int tpx7;
    jmp_buf Efor8J;
    int tpx8;
    jmp_buf Efor9J;
    int tpx9;
    jmp_buf Efor10J;
    int tpx10;
    jmp_buf Efor11J;
    int tpx11;
    jmp_buf Efor12J;
    int tpx12;
    jmp_buf Efor13J;
    int tpx13;
    unsigned char *tmp0 = new unsigned char[STR_MAX];
    unsigned char *tmp1 = new unsigned char[STR_MAX];
    unsigned char *tmp2 = new unsigned char[STR_MAX];
    unsigned char *tmp3 = new unsigned char[STR_MAX];
    unsigned char *tmp4 = new unsigned char[STR_MAX];
    unsigned char *tmp5 = new unsigned char[STR_MAX];
    unsigned char *tmp6 = new unsigned char[STR_MAX];
    unsigned char *tmp7 = new unsigned char[STR_MAX];
    unsigned char *_dummy = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *atmp =new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *xgtmp = new unsigned char [STR_MAX]; /* temporary variable */
    unsigned char *gtmpL = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *tmp = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *gtmp = new unsigned char [2*STR_MAX]; /* temporary variable */
    int _label_lookup(char *); /* resolution of labels */
    const char * _text_function(int);
    static unsigned char _ReturnVal[STR_MAX]; /* function returns */
    int _ArgCount=0; /* Nbr of args to extrinsic */
    long _i,_jj,_j,_k,_new;
    int _SymPush=0,f=0;
    int g=0;
    jmp_buf _doStack[128]; /* <do> return stack mechanism */
    short   _doStackN[128]= {0}; /* <do> return stack mechanism */
    static int     _doStx=0; /* <do> return stack mechanism */
    char _Refs[10][32];
    int _Refsx=0;

    if (svPtr == NULL) svPtr = AllocSV();

    _SymPush=0; // zap pushed tables

    svPtr->in_file[5]=stdin; // console default/
    svPtr->out_file[5]=stdout; // console default

    strcpy(svPtr->UDAT,"data.dat");
    strcpy(svPtr->UKEY,"key.dat");

    if ( 0) { // no alarm if slice is zero
        signal(SIGALRM, SyncClock);
        set_alarm(1);
        }

    __label_lookup = _label_lookup;
    __text_function = _text_function;

    $SymPut("%",argv[0]);

    if (argc > 0) {
        for (int i = 0; i < argc; i++) {
            char t[STR_MAX];
            sprintf(t,"%%%d", i);
            $SymPut(t, argv[i]);
            }
        }

    try {

//=================================================================================
        svPtr->LineNumber=8; //  kill ^query
//=================================================================================
        strmove( (UNS) gtmp, (UNS) "");
        strcat((char *) gtmp,(char *) "^query");
            {
            unsigned char tmp14[STR_MAX], tmp15[STR_MAX];
            keyfix(gtmp);
            _k = strlen((const char *) gtmp);
            strmove((UNS) tmp14, (UNS) gtmp);
            Mglobal(GKILL, gtmp, tmp15, svPtr);
            while(1) {
                _j = Mglobal(XNEXT, gtmp, tmp15, svPtr);
                if (_j && strncmp( (CCHR) tmp14, (CCHR) gtmp,_k) == 0) {
                    Mglobal(GKILL, gtmp, tmp15, svPtr);
                    continue;
                    }
                break;
                }
            }

//=================================================================================
        svPtr->LineNumber=9; //  kill ^ans
//=================================================================================
        strmove( (UNS) gtmp, (UNS) "");
        strcat((char *) gtmp,(char *) "^ans");
            {
            unsigned char tmp14[STR_MAX], tmp15[STR_MAX];
            keyfix(gtmp);
            _k = strlen((const char *) gtmp);
            strmove((UNS) tmp14, (UNS) gtmp);
            Mglobal(GKILL, gtmp, tmp15, svPtr);
            while(1) {
                _j = Mglobal(XNEXT, gtmp, tmp15, svPtr);
                if (_j && strncmp( (CCHR) tmp14, (CCHR) gtmp,_k) == 0) {
                    Mglobal(GKILL, gtmp, tmp15, svPtr);
                    continue;
                    }
                break;
                }
            }

//=================================================================================
        svPtr->LineNumber=10; //  kill ^tmp
//=================================================================================
        strmove( (UNS) gtmp, (UNS) "");
        strcat((char *) gtmp,(char *) "^tmp");
            {
            unsigned char tmp14[STR_MAX], tmp15[STR_MAX];
            keyfix(gtmp);
            _k = strlen((const char *) gtmp);
            strmove((UNS) tmp14, (UNS) gtmp);
            Mglobal(GKILL, gtmp, tmp15, svPtr);
            while(1) {
                _j = Mglobal(XNEXT, gtmp, tmp15, svPtr);
                if (_j && strncmp( (CCHR) tmp14, (CCHR) gtmp,_k) == 0) {
                    Mglobal(GKILL, gtmp, tmp15, svPtr);
                    continue;
                    }
                break;
                }
            }

//=================================================================================
        svPtr->LineNumber=12; //  for  do                    // extract query words to query vector
//=================================================================================

//--------------
//       For
//--------------

        while(1) {  /* Argumentless FOR */

//--------------
//       Do
//--------------

            tpx0 = svPtr->tpx;
            if ( (_i = setjmp(Efor0J)) == 0) goto Do_Block_Entry0; //else continue
            else if (_i == 100) goto Do_Block_Bypass0; // IF_flg m1402
            }
        goto Do_Block_Bypass0; // C3551 bypass indented group

Do_Block_Entry0:; // Enter Do Block

        do { /* dotted indent entry */

//=================================================================================
            svPtr->LineNumber=13; //  . set w=$zzscanalnum
//=================================================================================

//--------------
//       Set
//--------------

            strcpy((char *) &gtmp[1],(const char *) "$zzscanalnum");
            zfcn(gtmp,tmp1,svPtr);
            sym_(SYMSTORE, (UNS) "w", (UNS) tmp1, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=14; //  . if w="" break
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            if (strcmp((const char *) tmp0,(const char *) "")==0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                svPtr->tpx=tpx0; // break code: restore $test
                longjmp(Efor0J,100);
                }

//  terms

//=================================================================================
            svPtr->LineNumber=16; //  . set w1=$zstem(w)
//=================================================================================

//--------------
//       Set
//--------------

            strmove( (UNS) &gtmp[1], (UNS) "");
            catx = strxcat((char *) &gtmp[1],"$zstem\xce");
            if (sym_(SYMGET, (UNS) "w", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            strxcat((char *) catx,(char *) tmp1);
            strxcat((char *) catx,"\xcf");
            zfcn(gtmp,tmp2,svPtr);
            sym_(SYMSTORE, (UNS) "w1", (UNS) tmp2, svPtr); // Store result s274

//  unknown ?

//=================================================================================
            svPtr->LineNumber=18; //  . if '$data(^dict(w1)) write ?4,"unknown word: ",w,! quit
//=================================================================================

//--------------
//       If
//--------------

            strmove((UNS) tmp1, (UNS) "^dict\x01"); // init p674
            if (sym_(SYMGET, (UNS) "w1", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
            strcatx((UNS) tmp1, (UNS) tmp0);
            GlobalData(tmp1,tmp2,svPtr);
            if (numcomp1( (UNS) tmp2, 0) == 0)
                strmove( (UNS) tmp3, (UNS) "1");
            else strmove( (UNS) tmp3, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp3 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                        "4", svPtr->out_file[svPtr->io]); // tab operator
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 "unknown word: ");
                if (sym_(SYMGET, (UNS) "w", (UNS) tmp4, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp4);
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=19; //  . write !,"query term: ",w,!
//=================================================================================

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            fprintf(svPtr->out_file[svPtr->io], "\n");
            svPtr->hor[svPtr->io]=0;
            svPtr->ver[svPtr->io]++;
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             "query term: ");
            if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp0);
            fprintf(svPtr->out_file[svPtr->io], "\n");
            svPtr->hor[svPtr->io]=0;
            svPtr->ver[svPtr->io]++;

//  stems

//=================================================================================
            svPtr->LineNumber=21; //  . if $data(^stem(w1)) do
//=================================================================================

//--------------
//       If
//--------------

            strmove((UNS) tmp1, (UNS) "^stem\x01"); // init p674
            if (sym_(SYMGET, (UNS) "w1", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
            strcatx((UNS) tmp1, (UNS) tmp0);
            GlobalData(tmp1,tmp2,svPtr);
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp2 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                tpx1 = svPtr->tpx;
                if ( (_i = setjmp(Efor1J)) == 0) goto Do_Block_Entry1; //else continue
                else if (_i == 100) goto Do_Block_Bypass1; // IF_flg m1402
                }
            goto Do_Block_Bypass1; // C3551 bypass indented group

Do_Block_Entry1:; // Enter Do Block

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=22; //  .. write !,?4,"Words in this stem group are: "
//=================================================================================

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;
                _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                        "4", svPtr->out_file[svPtr->io]); // tab operator
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 "Words in this stem group are: ");

//=================================================================================
                svPtr->LineNumber=23; //  .. do stems(w1)
//=================================================================================

//--------------
//       Do
//--------------

                _ArgCount=0;  //section D1000
                svPtr->Rargsx=0;
                    {
                    if (sym_(SYMGET, (UNS) "w1", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
                    strmove((unsigned char *) __Arg0, (unsigned char *) tmp0); // arg setup D1003
                    _ArgCount=1;
                    _doStx++;
                    if (_doStx > 127 ) ErrorMessage("Too many function calls",svPtr->LineNumber);
                    sym_(99, (unsigned char *) "", (unsigned char *) "", svPtr);
                    if (setjmp(_doStack[_doStx])==0) goto stems;  /* Jump to function */
                    _doStx--;
                    strmove((unsigned char *) tmp1,(unsigned char *) _ReturnVal); // Copy result
                    }
                }
            while (0);   /* dotted un-indent 1 */
            longjmp(Efor1J,99); /* return */

Do_Block_Bypass1: ; // D3607

//=================================================================================
            svPtr->LineNumber=24; //  . else  write ?4,w," has no stem related words"
//=================================================================================

//--------------
//       Else
//--------------

            if (svPtr->tpx == 0) {

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                        "4", svPtr->out_file[svPtr->io]); // tab operator
                if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp0);
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 " has no stem related words");
                }

//  related

//=================================================================================
            svPtr->LineNumber=26; //  . write !,?4,"adding related phrase words: "
//=================================================================================

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            fprintf(svPtr->out_file[svPtr->io], "\n");
            svPtr->hor[svPtr->io]=0;
            svPtr->ver[svPtr->io]++;
            _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                    "4", svPtr->out_file[svPtr->io]); // tab operator
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             "adding related phrase words: ");

//=================================================================================
            svPtr->LineNumber=27; //  . if '$data(^phrase(w1)) do
//=================================================================================

//--------------
//       If
//--------------

            strmove((UNS) tmp1, (UNS) "^phrase\x01"); // init p674
            if (sym_(SYMGET, (UNS) "w1", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
            strcatx((UNS) tmp1, (UNS) tmp0);
            GlobalData(tmp1,tmp2,svPtr);
            if (numcomp1( (UNS) tmp2, 0) == 0)
                strmove( (UNS) tmp3, (UNS) "1");
            else strmove( (UNS) tmp3, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp3 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                tpx2 = svPtr->tpx;
                if ( (_i = setjmp(Efor2J)) == 0) goto Do_Block_Entry2; //else continue
                else if (_i == 100) goto Do_Block_Bypass2; // IF_flg m1402
                }
            goto Do_Block_Bypass2; // C3551 bypass indented group

Do_Block_Entry2:; // Enter Do Block

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=28; //  .. write "none",!
//=================================================================================

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 "none");
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;
                }
            while (0);   /* dotted un-indent 1 */
            longjmp(Efor2J,99); /* return */

Do_Block_Bypass2: ; // D3607

//=================================================================================
            svPtr->LineNumber=29; //  . else  do
//=================================================================================

//--------------
//       Else
//--------------

            if (svPtr->tpx == 0) {

//--------------
//       Do
//--------------

                tpx3 = svPtr->tpx;
                if ( (_i = setjmp(Efor3J)) == 0) goto Do_Block_Entry3; //else continue
                else if (_i == 100) goto Do_Block_Bypass3; // IF_flg m1402
                }
            goto Do_Block_Bypass3; // C3551 bypass indented group

Do_Block_Entry3:; // Enter Do Block

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=30; //  .. set f=1
//=================================================================================

//--------------
//       Set
//--------------

                sym_(SYMSTORE, (UNS) "f", (UNS) "1", svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=31; //  .. for prs=$order(^phrase(w1,prs)) do
//=================================================================================

//--------------
//       For
//--------------

                strcpy(for5_lim, "");
                sym_(SYMSTORE, (UNS) "prs", (UNS) "", svPtr); // init $ case 2518

For_Group5: // m2522

//	m2525
                strmove((UNS) tmp2, (UNS) "^phrase\x01"); // init p674
                if (sym_(SYMGET, (UNS) "w1", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
                strcatx((UNS) tmp2, (UNS) tmp0);
                if (sym_(SYMGET, (UNS) "prs", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "prs"); // not found
                strcatx((UNS) tmp2, (UNS) tmp1);
                GlobalOrder((unsigned char *) tmp2, (unsigned char *) tmp3,
                            (unsigned char *) NULL, svPtr); // p2236
                sym_(SYMSTORE, (UNS) "prs", (UNS) tmp3, svPtr); // set loop variable m2752
                if (strlen( (const char *) tmp3) == 0 ) goto For5Exit; // exit if empty 2758
                if ( setjmp( for5J ) == 0 ) goto For5;
                goto For_Group5; // m2771
                goto For5Exit; // bypass block

For5: // for loop body entry point B

                do { // for loop body
                    svPtr->LineNumber = 31;

//--------------
//       Do
//--------------

                    tpx4 = svPtr->tpx;
                    if ( (_i = setjmp(Efor4J)) == 0) goto Do_Block_Entry4; //else continue
                    else if (_i == 100) goto Do_Block_Bypass4; // IF_flg m1402
                    }
                while (0);
                longjmp(for5J, _i); // FOR loop 1 close

For5Exit: ; // exit for loop

                goto Do_Block_Bypass4; // C3551 bypass indented group

Do_Block_Entry4:; // Enter Do Block

                do { /* dotted indent entry */

//=================================================================================
                    svPtr->LineNumber=32; //  ... write prs," " set f=0
//=================================================================================

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    if (sym_(SYMGET, (UNS) "prs", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "prs"); // not found
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     tmp0);
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     " ");

//--------------
//       Set
//--------------

                    sym_(SYMSTORE, (UNS) "f", (UNS) "0", svPtr); // Store result s274

//=================================================================================
                    svPtr->LineNumber=33; //  ... if $x>60 w !,?26
//=================================================================================

//--------------
//       If
//--------------

                    sprintf((char *) tmp0,"%d",svPtr->hor[svPtr->io]); /* $x */
                    if (numcomp1((UNS) tmp0, 60) > 0) strmove((UNS) tmp1, (UNS) "1");
                    else strmove((UNS) tmp1, (UNS) "0");
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp1 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

                        if (svPtr->out_file[svPtr->io]==NULL)
                            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                        fprintf(svPtr->out_file[svPtr->io], "\n");
                        svPtr->hor[svPtr->io]=0;
                        svPtr->ver[svPtr->io]++;
                        _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                                "26", svPtr->out_file[svPtr->io]); // tab operator
                        }

//=================================================================================
                    svPtr->LineNumber=34; //  ... set ^query(prs)=1
//=================================================================================

//--------------
//       Set
//--------------

                    strmove((UNS) tmp1, (UNS) "query\xce"); // M3701
                    if (sym_(SYMGET, (UNS) "prs", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "prs"); // not found
                    catx = strxcat((char *) tmp1, (char *) tmp0); // a2926
                    strcat((char *) catx, (char *) "\xcf"); //a3956

                        {
                        f = Mglobal(STORE, tmp1, "1", svPtr);
                        }

                    }
                while (0);   /* dotted un-indent 2 */
                longjmp(Efor4J,99); /* return */

Do_Block_Bypass4: ; // D3607

//=================================================================================
                svPtr->LineNumber=35; //  .. if f write "none"
//=================================================================================

//--------------
//       If
//--------------

                svPtr->tpx = 0; //Default $Test indicator
                if (sym_(SYMGET, (UNS) "f", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "f"); // not found
                if (numcomp2((UNS) tmp0 )) { // Test if true
                    svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     "none");
                    }

//=================================================================================
                svPtr->LineNumber=36; //  .. write !
//=================================================================================

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;

//  soundex
                }
            while (0);   /* dotted un-indent 1 */
            longjmp(Efor3J,99); /* return */

Do_Block_Bypass3: ; // D3607

//=================================================================================
            svPtr->LineNumber=38; //  . set s=$zzsoundex(w1)
//=================================================================================

//--------------
//       Set
//--------------

            strmove( (UNS) &gtmp[1], (UNS) "");
            catx = strxcat((char *) &gtmp[1],"$zzsoundex\xce");
            if (sym_(SYMGET, (UNS) "w1", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
            strxcat((char *) catx,(char *) tmp1);
            strxcat((char *) catx,"\xcf");
            zfcn(gtmp,tmp2,svPtr);
            sym_(SYMSTORE, (UNS) "s", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=39; //  . write ?4,"words that may sound similar to ",w," ",$data(^sndx(s)),": "
//=================================================================================

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                    "4", svPtr->out_file[svPtr->io]); // tab operator
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             "words that may sound similar to ");
            if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp0);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ");
            strmove((UNS) tmp2, (UNS) "^sndx\x01"); // init p674
            if (sym_(SYMGET, (UNS) "s", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "s"); // not found
            strcatx((UNS) tmp2, (UNS) tmp1);
            GlobalData(tmp2,tmp3,svPtr);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp3);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             ": ");

//=================================================================================
            svPtr->LineNumber=40; //  . if '$data(^sndx(s)) w "none."
//=================================================================================

//--------------
//       If
//--------------

            strmove((UNS) tmp1, (UNS) "^sndx\x01"); // init p674
            if (sym_(SYMGET, (UNS) "s", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "s"); // not found
            strcatx((UNS) tmp1, (UNS) tmp0);
            GlobalData(tmp1,tmp2,svPtr);
            if (numcomp1( (UNS) tmp2, 0) == 0)
                strmove( (UNS) tmp3, (UNS) "1");
            else strmove( (UNS) tmp3, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp3 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 "none.");
                }

//=================================================================================
            svPtr->LineNumber=41; //  . else  do
//=================================================================================

//--------------
//       Else
//--------------

            if (svPtr->tpx == 0) {

//--------------
//       Do
//--------------

                tpx5 = svPtr->tpx;
                if ( (_i = setjmp(Efor5J)) == 0) goto Do_Block_Entry5; //else continue
                else if (_i == 100) goto Do_Block_Bypass5; // IF_flg m1402
                }
            goto Do_Block_Bypass5; // C3551 bypass indented group

Do_Block_Entry5:; // Enter Do Block

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=42; //  .. set f=1
//=================================================================================

//--------------
//       Set
//--------------

                sym_(SYMSTORE, (UNS) "f", (UNS) "1", svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=43; //  .. for ws=$order(^sndx(s,ws)) do
//=================================================================================

//--------------
//       For
//--------------

                strcpy(for8_lim, "");
                sym_(SYMSTORE, (UNS) "ws", (UNS) "", svPtr); // init $ case 2518

For_Group8: // m2522

//	m2525
                strmove((UNS) tmp2, (UNS) "^sndx\x01"); // init p674
                if (sym_(SYMGET, (UNS) "s", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "s"); // not found
                strcatx((UNS) tmp2, (UNS) tmp0);
                if (sym_(SYMGET, (UNS) "ws", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "ws"); // not found
                strcatx((UNS) tmp2, (UNS) tmp1);
                GlobalOrder((unsigned char *) tmp2, (unsigned char *) tmp3,
                            (unsigned char *) NULL, svPtr); // p2236
                sym_(SYMSTORE, (UNS) "ws", (UNS) tmp3, svPtr); // set loop variable m2752
                if (strlen( (const char *) tmp3) == 0 ) goto For8Exit; // exit if empty 2758
                if ( setjmp( for8J ) == 0 ) goto For8;
                goto For_Group8; // m2771
                goto For8Exit; // bypass block

For8: // for loop body entry point B

                do { // for loop body
                    svPtr->LineNumber = 43;

//--------------
//       Do
//--------------

                    tpx6 = svPtr->tpx;
                    if ( (_i = setjmp(Efor6J)) == 0) goto Do_Block_Entry6; //else continue
                    else if (_i == 100) goto Do_Block_Bypass6; // IF_flg m1402
                    }
                while (0);
                longjmp(for8J, _i); // FOR loop 1 close

For8Exit: ; // exit for loop

                goto Do_Block_Bypass6; // C3551 bypass indented group

Do_Block_Entry6:; // Enter Do Block

                do { /* dotted indent entry */

//=================================================================================
                    svPtr->LineNumber=44; //  ... if w1'=ws do
//=================================================================================

//--------------
//       If
//--------------

                    if (sym_(SYMGET, (UNS) "w1", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
                    if (sym_(SYMGET, (UNS) "ws", (UNS) tmp1, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "ws"); // not found
                    if (strcmp((const char *) tmp0, (const char *) tmp1) != 0)
                        strmove((UNS) tmp2, (UNS) "1");
                    else strmove((UNS) tmp2, (UNS) "0");
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp2 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                        tpx7 = svPtr->tpx;
                        if ( (_i = setjmp(Efor7J)) == 0) goto Do_Block_Entry7; //else continue
                        else if (_i == 100) goto Do_Block_Bypass7; // IF_flg m1402
                        }
                    goto Do_Block_Bypass7; // C3551 bypass indented group

Do_Block_Entry7:; // Enter Do Block

                    do { /* dotted indent entry */

//=================================================================================
                        svPtr->LineNumber=45; //  .... set f=0
//=================================================================================

//--------------
//       Set
//--------------

                        sym_(SYMSTORE, (UNS) "f", (UNS) "0", svPtr); // Store result s274

//=================================================================================
                        svPtr->LineNumber=46; //  .... do stems(ws)
//=================================================================================

//--------------
//       Do
//--------------

                        _ArgCount=0;  //section D1000
                        svPtr->Rargsx=0;
                            {
                            if (sym_(SYMGET, (UNS) "ws", (UNS) tmp0, svPtr) == NULL) // get value
                                VariableNotFound1(svPtr->LineNumber, (UNS) "ws"); // not found
                            strmove((unsigned char *) __Arg0, (unsigned char *) tmp0); // arg setup D1003
                            _ArgCount=1;
                            _doStx++;
                            if (_doStx > 127 ) ErrorMessage("Too many function calls",svPtr->LineNumber);
                            sym_(99, (unsigned char *) "", (unsigned char *) "", svPtr);
                            if (setjmp(_doStack[_doStx])==0) goto stems;  /* Jump to function */
                            _doStx--;
                            strmove((unsigned char *) tmp1,(unsigned char *) _ReturnVal); // Copy result
                            }
                        }
                    while (0);   /* dotted un-indent 3 */
                    longjmp(Efor7J,99); /* return */

Do_Block_Bypass7: ; // D3607
                    }
                while (0);   /* dotted un-indent 2 */
                longjmp(Efor6J,99); /* return */

Do_Block_Bypass6: ; // D3607

//=================================================================================
                svPtr->LineNumber=47; //  .. if f write "none"
//=================================================================================

//--------------
//       If
//--------------

                svPtr->tpx = 0; //Default $Test indicator
                if (sym_(SYMGET, (UNS) "f", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "f"); // not found
                if (numcomp2((UNS) tmp0 )) { // Test if true
                    svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     "none");
                    }
                }
            while (0);   /* dotted un-indent 1 */
            longjmp(Efor5J,99); /* return */

Do_Block_Bypass5: ; // D3607

//=================================================================================
            svPtr->LineNumber=48; //  . if $x'=26 write !
//=================================================================================

//--------------
//       If
//--------------

            sprintf((char *) tmp0,"%d",svPtr->hor[svPtr->io]); /* $x */
            if (strcmp((const char *) tmp0, (const char *) "26") != 0)
                strmove((UNS) tmp1, (UNS) "1");
            else strmove((UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;
                }

//  query word

//=================================================================================
            svPtr->LineNumber=50; //  . set ^query(w)=3
//=================================================================================

//--------------
//       Set
//--------------

            strmove((UNS) tmp1, (UNS) "query\xce"); // M3701
            if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            catx = strxcat((char *) tmp1, (char *) tmp0); // a2926
            strcat((char *) catx, (char *) "\xcf"); //a3956

                {
                f = Mglobal(STORE, tmp1, "3", svPtr);
                }


//  Find documents containing one or more query terms.

//=================================================================================
            svPtr->LineNumber=54; //       . for d=$order(^index(w,d)) set ^tmp(d)=""  // retain doc id
//=================================================================================

//--------------
//       For
//--------------

            strcpy(for11_lim, "");
            sym_(SYMSTORE, (UNS) "d", (UNS) "", svPtr); // init $ case 2518

For_Group11: // m2522

//	m2525
            strmove((UNS) tmp2, (UNS) "^index\x01"); // init p674
            if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            strcatx((UNS) tmp2, (UNS) tmp0);
            if (sym_(SYMGET, (UNS) "d", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
            strcatx((UNS) tmp2, (UNS) tmp1);
            GlobalOrder((unsigned char *) tmp2, (unsigned char *) tmp3,
                        (unsigned char *) NULL, svPtr); // p2236
            sym_(SYMSTORE, (UNS) "d", (UNS) tmp3, svPtr); // set loop variable m2752
            if (strlen( (const char *) tmp3) == 0 ) goto For11Exit; // exit if empty 2758
            if ( setjmp( for11J ) == 0 ) goto For11;
            goto For_Group11; // m2771
            goto For11Exit; // bypass block

For11: // for loop body entry point B

            do { // for loop body
                svPtr->LineNumber = 54;

//--------------
//       Set
//--------------

                strmove((UNS) tmp5, (UNS) "tmp\xce"); // M3701
                if (sym_(SYMGET, (UNS) "d", (UNS) tmp4, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
                catx = strxcat((char *) tmp5, (char *) tmp4); // a2926
                strcat((char *) catx, (char *) "\xcf"); //a3956

                    {
                    f = Mglobal(STORE, tmp5, "", svPtr);
                    }

                }
            while (0);
            longjmp(for11J, _i); // FOR loop 1 close

For11Exit: ; // exit for loop

            }
        while(0);   // dotted un-indent 0
        longjmp(Efor0J,99); // return

Do_Block_Bypass0: ; //B848


//=================================================================================
        svPtr->LineNumber=56; //       set time0=$zd1
//=================================================================================

//--------------
//       Set
//--------------

        strcpy((char *) &gtmp[1],(const char *) "$zd1");
        zfcn(gtmp,tmp1,svPtr);
        sym_(SYMSTORE, (UNS) "time0", (UNS) tmp1, svPtr); // Store result s274

//=================================================================================
        svPtr->LineNumber=57; //       write !
//=================================================================================

//--------------
//       Write
//--------------

        if (svPtr->out_file[svPtr->io]==NULL)
            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
        fprintf(svPtr->out_file[svPtr->io], "\n");
        svPtr->hor[svPtr->io]=0;
        svPtr->ver[svPtr->io]++;

//=================================================================================
        svPtr->LineNumber=59; //       set file=$j_".tmp"
//=================================================================================

//--------------
//       Set
//--------------

        sprintf((char *) tmp1,"%d",getpid()); //$job linux
        if (strlen((const char *) tmp1) + strlen((const char *) ".tmp") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
        strmove( (UNS) tmp2, (UNS) tmp1);
        strcat( (char *) tmp2, (char *) ".tmp");
        sym_(SYMSTORE, (UNS) "file", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
        svPtr->LineNumber=60; //       open 1:file_",new"
//=================================================================================

//--------------
//       Open
//--------------

        _i = atoi( CSTR "1");
        if (sym_(SYMGET, (UNS) "file", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "file"); // not found
        if (strlen((const char *) tmp0) + strlen((const char *) ",new") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
        strmove( (UNS) tmp1, (UNS) tmp0);
        strcat( (char *) tmp1, (char *) ",new");
        strmove((UNS) tmp0, (UNS) tmp1);
        for(_j=0; tmp0[_j]!=0 && tmp0[_j]!=','; _j++);
        if (tmp0[_j]!=',') ErrorMessage("File open error",svPtr->LineNumber);
        tmp0[_j++]=0;
        strmove((UNS) gtmp, (UNS) tmp0);
        if (strcmp( (CCHR) &tmp0[_j], (CCHR) "old") == 0 ||
                strcmp( (CCHR) &tmp0[_j], (CCHR) "OLD") == 0) _new = 0;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "new") == 0 ||
                 strcmp((CCHR) &tmp0[_j], (CCHR) "NEW") == 0) _new = 1;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "append") == 0 ||
                 strcmp( (CCHR) &tmp0[_j], (const char *) "APPEND") == 0) _new=2;
        else ErrorMessage("File open error",svPtr->LineNumber);
        if (svPtr->out_file[_i] != NULL || svPtr->in_file[_i] != NULL)
            ErrorMessage("File already open", svPtr->LineNumber);
        if (_new==1) { /* output */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "w");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else if (_new == 2) { /* append */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "a");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else { /* input */
            svPtr->in_file[_i] = fopen((const char *) gtmp, "r");
            if(svPtr->in_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }

//=================================================================================
        svPtr->LineNumber=62; //       set f=0
//=================================================================================

//--------------
//       Set
//--------------

        sym_(SYMSTORE, (UNS) "f", (UNS) "0", svPtr); // Store result s274

//=================================================================================
        svPtr->LineNumber=64; //       for i=$order(^tmp(i)) do  // calculate cosine between query and each doc
//=================================================================================

//--------------
//       For
//--------------

        strcpy(for12_lim, "");
        sym_(SYMSTORE, (UNS) "i", (UNS) "", svPtr); // init $ case 2518

For_Group12: // m2522

//	m2525
        strmove((UNS) tmp1, (UNS) "^tmp\x01"); // init p674
        if (sym_(SYMGET, (UNS) "i", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "i"); // not found
        strcatx((UNS) tmp1, (UNS) tmp0);
        GlobalOrder((unsigned char *) tmp1, (unsigned char *) tmp2,
                    (unsigned char *) NULL, svPtr); // p2236
        sym_(SYMSTORE, (UNS) "i", (UNS) tmp2, svPtr); // set loop variable m2752
        if (strlen( (const char *) tmp2) == 0 ) goto For12Exit; // exit if empty 2758
        if ( setjmp( for12J ) == 0 ) goto For12;
        goto For_Group12; // m2771
        goto For12Exit; // bypass block

For12: // for loop body entry point B

        do { // for loop body
            svPtr->LineNumber = 64;

//--------------
//       Do
//--------------

            tpx8 = svPtr->tpx;
            if ( (_i = setjmp(Efor8J)) == 0) goto Do_Block_Entry8; //else continue
            else if (_i == 100) goto Do_Block_Bypass8; // IF_flg m1402
            }
        while (0);
        longjmp(for12J, _i); // FOR loop 1 close

For12Exit: ; // exit for loop

        goto Do_Block_Bypass8; // C3551 bypass indented group

Do_Block_Entry8:; // Enter Do Block

        do { /* dotted indent entry */

//=================================================================================
            svPtr->LineNumber=65; //       . set c=$zzcosine(^doc(i),^query)   // MDH cosine calculation
//=================================================================================

//--------------
//       Set
//--------------

            strmove((UNS) tmp2, (UNS) "^doc\x01"); // init p674
            if (sym_(SYMGET, (UNS) "i", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "i"); // not found
            strcatx((UNS) tmp2, (UNS) tmp1);
            strmove((UNS) tmp4, (UNS) "^query\x0"); // init p674
            strmove( (UNS) &gtmp[1], (UNS) "");
            catx = strxcat((char *) &gtmp[1],"$zzcosine\xce");
            strxcat((char *) catx,(char *) tmp2);
            strxcat((char *) catx,"\xd0");
            strxcat((char *) catx,(char *) tmp4);
            strxcat((char *) catx,"\xcf");
            zfcn(gtmp,tmp6,svPtr);
            sym_(SYMSTORE, (UNS) "c", (UNS) tmp6, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=66; //       . if c>0 use 1 write $justify(c,5,3)," ",i,! set f=f+1
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "c", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "c"); // not found
            if (numcomp1((UNS) tmp0, 0) > 0) strmove((UNS) tmp1, (UNS) "1");
            else strmove((UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Use
//--------------

                svPtr->io=atoi( CSTR "1");

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                if (sym_(SYMGET, (UNS) "c", (UNS) tmp2, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "c"); // not found
                _justify( (UNS) tmp3, (UNS) tmp2, (UNS)"5", (UNS)"3");
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp3);
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 " ");
                if (sym_(SYMGET, (UNS) "i", (UNS) tmp4, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "i"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp4);
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "f", (UNS) tmp6, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "f"); // not found
                add( (char *) tmp6, "1", (char *) tmp7 );
                sym_(SYMSTORE, (UNS) "f", (UNS) tmp7, svPtr); // Store result s274
                }
            }
        while(0);   // dotted un-indent 0
        longjmp(Efor8J,99); // return

Do_Block_Bypass8: ; //B848


//=================================================================================
        svPtr->LineNumber=68; //       close 1
//=================================================================================

//--------------
//       Close
//--------------

        _i=atoi( CSTR "1");
        if (svPtr->in_file[_i] == NULL && svPtr->out_file[_i] == NULL)
            ErrorMessage("Attempt to close unopened file", svPtr->LineNumber);
        if (svPtr->in_file[_i]!=NULL) {
            fclose(svPtr->in_file[_i]);
            svPtr->in_file[_i]=NULL;
            }
        else {
            fclose(svPtr->out_file[_i]);
            svPtr->out_file[_i]=NULL;
            }

//=================================================================================
        svPtr->LineNumber=69; //       use 5
//=================================================================================

//--------------
//       Use
//--------------

        svPtr->io=atoi( CSTR "5");

//=================================================================================
        svPtr->LineNumber=70; //       if 'f halt
//=================================================================================

//--------------
//       If
//--------------

        if (sym_(SYMGET, (UNS) "f", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "f"); // not found
        if (numcomp1( (UNS) tmp0, 0) == 0)
            strmove( (UNS) tmp1, (UNS) "1");
        else strmove( (UNS) tmp1, (UNS) "0");
        svPtr->tpx = 0; //Default $Test indicator
        if (numcomp2((UNS) tmp1 )) { // Test if true
            svPtr->tpx = 1; // $test becomes true

//--------------
//       Halt
//--------------

            goto _epilogue;
            }

//=================================================================================
        svPtr->LineNumber=72; //       set outfile="sorted"_file
//=================================================================================

//--------------
//       Set
//--------------

        if (sym_(SYMGET, (UNS) "file", (UNS) tmp1, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "file"); // not found
        if (strlen((const char *) "sorted") + strlen((const char *) tmp1) + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
        strmove( (UNS) tmp2, (UNS) "sorted");
        strcat( (char *) tmp2, (char *) tmp1);
        sym_(SYMSTORE, (UNS) "outfile", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
        svPtr->LineNumber=73; //       shell sort -nr < &~file~ > &~outfile~
//=================================================================================

//--------------
//       Shell
//--------------

        _jj = Interpret( (CCHR)
                         "shell sort -nr < &~file~ > &~outfile~", svPtr);
        svPtr->ERROR = _jj;
        if (!svPtr->NOERR && _jj < 0)
            ErrorMessage("Indirection error", svPtr->LineNumber);

//=================================================================================
        svPtr->LineNumber=75; //       open 1:"sorted"_file_",old"
//=================================================================================

//--------------
//       Open
//--------------

        _i = atoi( CSTR "1");
        if (sym_(SYMGET, (UNS) "file", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "file"); // not found
        if (strlen((const char *) "sorted") + strlen((const char *) tmp0) + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
        strmove( (UNS) tmp1, (UNS) "sorted");
        strcat( (char *) tmp1, (char *) tmp0);
        if (strlen((const char *) tmp1) + strlen((const char *) ",old") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
        strmove( (UNS) tmp2, (UNS) tmp1);
        strcat( (char *) tmp2, (char *) ",old");
        strmove((UNS) tmp0, (UNS) tmp2);
        for(_j=0; tmp0[_j]!=0 && tmp0[_j]!=','; _j++);
        if (tmp0[_j]!=',') ErrorMessage("File open error",svPtr->LineNumber);
        tmp0[_j++]=0;
        strmove((UNS) gtmp, (UNS) tmp0);
        if (strcmp( (CCHR) &tmp0[_j], (CCHR) "old") == 0 ||
                strcmp( (CCHR) &tmp0[_j], (CCHR) "OLD") == 0) _new = 0;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "new") == 0 ||
                 strcmp((CCHR) &tmp0[_j], (CCHR) "NEW") == 0) _new = 1;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "append") == 0 ||
                 strcmp( (CCHR) &tmp0[_j], (const char *) "APPEND") == 0) _new=2;
        else ErrorMessage("File open error",svPtr->LineNumber);
        if (svPtr->out_file[_i] != NULL || svPtr->in_file[_i] != NULL)
            ErrorMessage("File already open", svPtr->LineNumber);
        if (_new==1) { /* output */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "w");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else if (_new == 2) { /* append */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "a");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else { /* input */
            svPtr->in_file[_i] = fopen((const char *) gtmp, "r");
            if(svPtr->in_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }

//=================================================================================
        svPtr->LineNumber=77; //       use 5
//=================================================================================

//--------------
//       Use
//--------------

        svPtr->io=atoi( CSTR "5");

//=================================================================================
        svPtr->LineNumber=78; //       write f," documents found.",!!
//=================================================================================

//--------------
//       Write
//--------------

        if (svPtr->out_file[svPtr->io]==NULL)
            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
        if (sym_(SYMGET, (UNS) "f", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "f"); // not found
        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                         tmp0);
        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                         " documents found.");
        fprintf(svPtr->out_file[svPtr->io], "\n");
        svPtr->hor[svPtr->io]=0;
        svPtr->ver[svPtr->io]++;
        fprintf(svPtr->out_file[svPtr->io], "\n");
        svPtr->hor[svPtr->io]=0;
        svPtr->ver[svPtr->io]++;

//=================================================================================
        svPtr->LineNumber=79; //       write "   Doc Rel   Title",!
//=================================================================================

//--------------
//       Write
//--------------

        if (svPtr->out_file[svPtr->io]==NULL)
            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                         "   Doc Rel   Title");
        fprintf(svPtr->out_file[svPtr->io], "\n");
        svPtr->hor[svPtr->io]=0;
        svPtr->ver[svPtr->io]++;

//=================================================================================
        svPtr->LineNumber=81; //       open 4:"rslt.1,new"
//=================================================================================

//--------------
//       Open
//--------------

        _i = atoi( CSTR "4");
        strmove((UNS) tmp0, (UNS) "rslt.1,new");
        for(_j=0; tmp0[_j]!=0 && tmp0[_j]!=','; _j++);
        if (tmp0[_j]!=',') ErrorMessage("File open error",svPtr->LineNumber);
        tmp0[_j++]=0;
        strmove((UNS) gtmp, (UNS) tmp0);
        if (strcmp( (CCHR) &tmp0[_j], (CCHR) "old") == 0 ||
                strcmp( (CCHR) &tmp0[_j], (CCHR) "OLD") == 0) _new = 0;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "new") == 0 ||
                 strcmp((CCHR) &tmp0[_j], (CCHR) "NEW") == 0) _new = 1;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "append") == 0 ||
                 strcmp( (CCHR) &tmp0[_j], (const char *) "APPEND") == 0) _new=2;
        else ErrorMessage("File open error",svPtr->LineNumber);
        if (svPtr->out_file[_i] != NULL || svPtr->in_file[_i] != NULL)
            ErrorMessage("File already open", svPtr->LineNumber);
        if (_new==1) { /* output */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "w");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else if (_new == 2) { /* append */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "a");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else { /* input */
            svPtr->in_file[_i] = fopen((const char *) gtmp, "r");
            if(svPtr->in_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }

//=================================================================================
        svPtr->LineNumber=83; //       for i=1:1:10 do   // display loop
//=================================================================================

//--------------
//       For
//--------------

        strcpy(for14_lim, "");
//	m2525
        strmove((UNS) for14_init, (UNS) "1"); // init value m2534
        strmove( (UNS) for14_incr, (UNS) "1"); // inc/dec m2575
        strmove((UNS) for14_lim, (UNS) "10"); // limit value

        if (strchr((char *) for14_incr, '.')) { // inc/dec is float
            for14D = atof(for14_incr); // inc/dec value
            for14F = for14D < 0.0 ? 1 : 0; // incr or decr?
            }
        else { // inc/dec is integer
            for14 = atol(for14_incr); // inc/dec value
            for14F = for14 < 0 ? 1 : 0; // incr or decr?
            }

        for ( sym_(SYMSTORE, (UNS) "i", (UNS) for14_init, svPtr); // init 2618

                for14F ? // loop limit test direction
                numcomp((UNS) sym_(11, (UNS) "i",
                                   _dummy, svPtr),
                        (UNS) for14_lim) >= 0 // GE limit value?
                : // ternary operator
                numcomp((UNS) sym_(11, (UNS) "i",
                                   _dummy,svPtr),
                        (UNS) for14_lim) <= 0; // LE limit value

                add( sym_(11, (UNS) "i", _dummy, svPtr), // inc/dec loop var
                     for14_incr, (char *) _dummy),
                sym_(SYMSTORE, (UNS) "i", (UNS) _dummy, svPtr) ) // store rslt

            if ((_i = setjmp(for14J)) == 0) goto For14; // else continue

            else if (_i == 100) goto For14Exit; // f273

        goto For14Exit; // bypass block

For14: // for loop body entry point B

        do { // for loop body
            svPtr->LineNumber = 83;

//--------------
//       Do
//--------------

            tpx9 = svPtr->tpx;
            if ( (_i = setjmp(Efor9J)) == 0) goto Do_Block_Entry9; //else continue
            else if (_i == 100) goto Do_Block_Bypass9; // IF_flg m1402
            }
        while (0);
        longjmp(for14J, _i); // FOR loop 1 close

For14Exit: ; // exit for loop

        goto Do_Block_Bypass9; // C3551 bypass indented group

Do_Block_Entry9:; // Enter Do Block

        do { /* dotted indent entry */

//=================================================================================
            svPtr->LineNumber=84; //       . use 1 read a
//=================================================================================

//--------------
//       Use
//--------------

            svPtr->io=atoi( CSTR "1");

//--------------
//       Read
//--------------

            if (svPtr->in_file[svPtr->io] == NULL)
                ErrorMessage("Read from input file", svPtr->LineNumber);
            svPtr->tpx = getstr1(svPtr->in_file[svPtr->io], &gtmp); // Read string into gtmp
            if (svPtr->tpx >= 0) svPtr->tpx = 1;
            else svPtr->tpx = 0; // Set $Test
            sym_(SYMSTORE, (UNS) "a", (UNS) gtmp, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=85; //       . if '$test break
//=================================================================================

//--------------
//       If
//--------------

            if (svPtr->tpx) tmp0[0]='1'; /* $test */
            else tmp0[0]='0';
            tmp0[1]='\0';
            if (numcomp1( (UNS) tmp0, 0) == 0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                svPtr->tpx=tpx9; // break code: restore $test
                longjmp(Efor9J,100);
                }

//=================================================================================
            svPtr->LineNumber=86; //       . set d=$piece(a," ",2)
//=================================================================================

//--------------
//       Set
//--------------

            if (sym_(SYMGET, (UNS) "a", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "a"); // not found
            _piece((UNS) tmp2,
                   (UNS) tmp1,(UNS) " ",(UNS) "2", (UNS) "-1",
                   0, (UNS) "", svPtr); // p1136
            sym_(SYMSTORE, (UNS) "d", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=87; //       . set c=$piece(a," ",1)
//=================================================================================

//--------------
//       Set
//--------------

            if (sym_(SYMGET, (UNS) "a", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "a"); // not found
            _piece((UNS) tmp2,
                   (UNS) tmp1,(UNS) " ",(UNS) "1", (UNS) "-1",
                   0, (UNS) "", svPtr); // p1136
            sym_(SYMSTORE, (UNS) "c", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=88; //       . use 5 write $justify(d,6)," ",c," ",$e(^title(d),1,70)," ...",!
//=================================================================================

//--------------
//       Use
//--------------

            svPtr->io=atoi( CSTR "5");

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            if (sym_(SYMGET, (UNS) "d", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
            _justify( (UNS) tmp1, (UNS) tmp0, (UNS)"6", (UNS) "-1");
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp1);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ");
            if (sym_(SYMGET, (UNS) "c", (UNS) tmp2, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "c"); // not found
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp2);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ");
            strmove((UNS) tmp4, (UNS) "^title\x01"); // init p674
            if (sym_(SYMGET, (UNS) "d", (UNS) tmp3, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
            strcatx((UNS) tmp4, (UNS) tmp3);
            if (!Mglobal(RETRIEVE, tmp4, tmp5, svPtr)) // retrieve global
                VariableNotFound(svPtr->LineNumber, tmp4);
            _extract( (UNS) tmp6,
                      (UNS) tmp5, (UNS) "1", (UNS) "70"); // p2493
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp6);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ...");
            fprintf(svPtr->out_file[svPtr->io], "\n");
            svPtr->hor[svPtr->io]=0;
            svPtr->ver[svPtr->io]++;

//=================================================================================
            svPtr->LineNumber=89; //       . use 4 write c," ",d," ",$e(^title(d),1,70)," ...### "
//=================================================================================

//--------------
//       Use
//--------------

            svPtr->io=atoi( CSTR "4");

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            if (sym_(SYMGET, (UNS) "c", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "c"); // not found
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp0);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ");
            if (sym_(SYMGET, (UNS) "d", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp1);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ");
            strmove((UNS) tmp3, (UNS) "^title\x01"); // init p674
            if (sym_(SYMGET, (UNS) "d", (UNS) tmp2, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
            strcatx((UNS) tmp3, (UNS) tmp2);
            if (!Mglobal(RETRIEVE, tmp3, tmp4, svPtr)) // retrieve global
                VariableNotFound(svPtr->LineNumber, tmp3);
            _extract( (UNS) tmp5,
                      (UNS) tmp4, (UNS) "1", (UNS) "70"); // p2493
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp5);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ...### ");

//=================================================================================
            svPtr->LineNumber=90; //       . use 5 write ?14,"matched keys: "
//=================================================================================

//--------------
//       Use
//--------------

            svPtr->io=atoi( CSTR "5");

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                    "14", svPtr->out_file[svPtr->io]); // tab operator
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             "matched keys: ");

//=================================================================================
            svPtr->LineNumber=91; //       . for w=$order(^doc(d,w)) do
//=================================================================================

//--------------
//       For
//--------------

            strcpy(for16_lim, "");
            sym_(SYMSTORE, (UNS) "w", (UNS) "", svPtr); // init $ case 2518

For_Group16: // m2522

//	m2525
            strmove((UNS) tmp2, (UNS) "^doc\x01"); // init p674
            if (sym_(SYMGET, (UNS) "d", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "d"); // not found
            strcatx((UNS) tmp2, (UNS) tmp0);
            if (sym_(SYMGET, (UNS) "w", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
            strcatx((UNS) tmp2, (UNS) tmp1);
            GlobalOrder((unsigned char *) tmp2, (unsigned char *) tmp3,
                        (unsigned char *) NULL, svPtr); // p2236
            sym_(SYMSTORE, (UNS) "w", (UNS) tmp3, svPtr); // set loop variable m2752
            if (strlen( (const char *) tmp3) == 0 ) goto For16Exit; // exit if empty 2758
            if ( setjmp( for16J ) == 0 ) goto For16;
            goto For_Group16; // m2771
            goto For16Exit; // bypass block

For16: // for loop body entry point B

            do { // for loop body
                svPtr->LineNumber = 91;

//--------------
//       Do
//--------------

                tpx10 = svPtr->tpx;
                if ( (_i = setjmp(Efor10J)) == 0) goto Do_Block_Entry10; //else continue
                else if (_i == 100) goto Do_Block_Bypass10; // IF_flg m1402
                }
            while (0);
            longjmp(for16J, _i); // FOR loop 1 close

For16Exit: ; // exit for loop

            goto Do_Block_Bypass10; // C3551 bypass indented group

Do_Block_Entry10:; // Enter Do Block

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=92; //       .. if $data(^query(w)) do
//=================================================================================

//--------------
//       If
//--------------

                strmove((UNS) tmp1, (UNS) "^query\x01"); // init p674
                if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                strcatx((UNS) tmp1, (UNS) tmp0);
                GlobalData(tmp1,tmp2,svPtr);
                svPtr->tpx = 0; //Default $Test indicator
                if (numcomp2((UNS) tmp2 )) { // Test if true
                    svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                    tpx11 = svPtr->tpx;
                    if ( (_i = setjmp(Efor11J)) == 0) goto Do_Block_Entry11; //else continue
                    else if (_i == 100) goto Do_Block_Bypass11; // IF_flg m1402
                    }
                goto Do_Block_Bypass11; // C3551 bypass indented group

Do_Block_Entry11:; // Enter Do Block

                do { /* dotted indent entry */

//=================================================================================
                    svPtr->LineNumber=93; //       ... if $data(^stem(w)) do
//=================================================================================

//--------------
//       If
//--------------

                    strmove((UNS) tmp1, (UNS) "^stem\x01"); // init p674
                    if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                    strcatx((UNS) tmp1, (UNS) tmp0);
                    GlobalData(tmp1,tmp2,svPtr);
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp2 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                        tpx12 = svPtr->tpx;
                        if ( (_i = setjmp(Efor12J)) == 0) goto Do_Block_Entry12; //else continue
                        else if (_i == 100) goto Do_Block_Bypass12; // IF_flg m1402
                        }
                    goto Do_Block_Bypass12; // C3551 bypass indented group

Do_Block_Entry12:; // Enter Do Block

                    do { /* dotted indent entry */

//=================================================================================
                        svPtr->LineNumber=94; //       .... for w1=$order(^stem(w,w1)) use 5 write w1," " use 4 write w1," "
//=================================================================================

//--------------
//       For
//--------------

                        strcpy(for20_lim, "");
                        sym_(SYMSTORE, (UNS) "w1", (UNS) "", svPtr); // init $ case 2518

For_Group20: // m2522

//	m2525
                        strmove((UNS) tmp2, (UNS) "^stem\x01"); // init p674
                        if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                            VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                        strcatx((UNS) tmp2, (UNS) tmp0);
                        if (sym_(SYMGET, (UNS) "w1", (UNS) tmp1, svPtr) == NULL) // get value
                            VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
                        strcatx((UNS) tmp2, (UNS) tmp1);
                        GlobalOrder((unsigned char *) tmp2, (unsigned char *) tmp3,
                                    (unsigned char *) NULL, svPtr); // p2236
                        sym_(SYMSTORE, (UNS) "w1", (UNS) tmp3, svPtr); // set loop variable m2752
                        if (strlen( (const char *) tmp3) == 0 ) goto For20Exit; // exit if empty 2758
                        if ( setjmp( for20J ) == 0 ) goto For20;
                        goto For_Group20; // m2771
                        goto For20Exit; // bypass block

For20: // for loop body entry point B

                        do { // for loop body
                            svPtr->LineNumber = 94;

//--------------
//       Use
//--------------

                            svPtr->io=atoi( CSTR "5");

//--------------
//       Write
//--------------

                            if (svPtr->out_file[svPtr->io]==NULL)
                                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                            if (sym_(SYMGET, (UNS) "w1", (UNS) tmp4, svPtr) == NULL) // get value
                                VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
                            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                             tmp4);
                            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                             " ");

//--------------
//       Use
//--------------

                            svPtr->io=atoi( CSTR "4");

//--------------
//       Write
//--------------

                            if (svPtr->out_file[svPtr->io]==NULL)
                                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                            if (sym_(SYMGET, (UNS) "w1", (UNS) tmp5, svPtr) == NULL) // get value
                                VariableNotFound1(svPtr->LineNumber, (UNS) "w1"); // not found
                            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                             tmp5);
                            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                             " ");
                            }
                        while (0);
                        longjmp(for20J, _i); // FOR loop 1 close

For20Exit: ; // exit for loop

                        }
                    while (0);   /* dotted un-indent 3 */
                    longjmp(Efor12J,99); /* return */

Do_Block_Bypass12: ; // D3607

//=================================================================================
                    svPtr->LineNumber=95; //       ... else  use 5 write "*",w," " write:$x>60 ?26 use 4 write "*",w," "
//=================================================================================

//--------------
//       Else
//--------------

                    if (svPtr->tpx == 0) {

//--------------
//       Use
//--------------

                        svPtr->io=atoi( CSTR "5");

//--------------
//       Write
//--------------

                        if (svPtr->out_file[svPtr->io]==NULL)
                            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                         "*");
                        if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                            VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                         tmp0);
                        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                         " ");
                        sprintf((char *) tmp1,"%d",svPtr->hor[svPtr->io]); /* $x */
                        if (numcomp1((UNS) tmp1, 60) > 0) strmove((UNS) tmp2, (UNS) "1");
                        else strmove((UNS) tmp2, (UNS) "0");
                        if (atoi( CSTR tmp2)) { // m859 postconditional

//--------------
//       Write
//--------------

                            if (svPtr->out_file[svPtr->io]==NULL)
                                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                            _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                                    "26", svPtr->out_file[svPtr->io]); // tab operator
                            } /* post conditional 4092*/

//--------------
//       Use
//--------------

                        svPtr->io=atoi( CSTR "4");

//--------------
//       Write
//--------------

                        if (svPtr->out_file[svPtr->io]==NULL)
                            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                         "*");
                        if (sym_(SYMGET, (UNS) "w", (UNS) tmp3, svPtr) == NULL) // get value
                            VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                         tmp3);
                        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                         " ");
                        }
                    }
                while (0);   /* dotted un-indent 2 */
                longjmp(Efor11J,99); /* return */

Do_Block_Bypass11: ; // D3607
                }
            while (0);   /* dotted un-indent 1 */
            longjmp(Efor10J,99); /* return */

Do_Block_Bypass10: ; // D3607

//=================================================================================
            svPtr->LineNumber=96; //       . use 5 write ! use 4 write !
//=================================================================================

//--------------
//       Use
//--------------

            svPtr->io=atoi( CSTR "5");

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            fprintf(svPtr->out_file[svPtr->io], "\n");
            svPtr->hor[svPtr->io]=0;
            svPtr->ver[svPtr->io]++;

//--------------
//       Use
//--------------

            svPtr->io=atoi( CSTR "4");

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            fprintf(svPtr->out_file[svPtr->io], "\n");
            svPtr->hor[svPtr->io]=0;
            svPtr->ver[svPtr->io]++;
            }
        while(0);   // dotted un-indent 0
        longjmp(Efor9J,99); // return

Do_Block_Bypass9: ; //B848


//=================================================================================
        svPtr->LineNumber=98; //       close 4
//=================================================================================

//--------------
//       Close
//--------------

        _i=atoi( CSTR "4");
        if (svPtr->in_file[_i] == NULL && svPtr->out_file[_i] == NULL)
            ErrorMessage("Attempt to close unopened file", svPtr->LineNumber);
        if (svPtr->in_file[_i]!=NULL) {
            fclose(svPtr->in_file[_i]);
            svPtr->in_file[_i]=NULL;
            }
        else {
            fclose(svPtr->out_file[_i]);
            svPtr->out_file[_i]=NULL;
            }

//=================================================================================
        svPtr->LineNumber=100; //       use 5
//=================================================================================

//--------------
//       Use
//--------------

        svPtr->io=atoi( CSTR "5");

//=================================================================================
        svPtr->LineNumber=101; //       close 1
//=================================================================================

//--------------
//       Close
//--------------

        _i=atoi( CSTR "1");
        if (svPtr->in_file[_i] == NULL && svPtr->out_file[_i] == NULL)
            ErrorMessage("Attempt to close unopened file", svPtr->LineNumber);
        if (svPtr->in_file[_i]!=NULL) {
            fclose(svPtr->in_file[_i]);
            svPtr->in_file[_i]=NULL;
            }
        else {
            fclose(svPtr->out_file[_i]);
            svPtr->out_file[_i]=NULL;
            }

//=================================================================================
        svPtr->LineNumber=103; //       write !,"*Time used: ",$zd1-time0," seconds",!
//=================================================================================

//--------------
//       Write
//--------------

        if (svPtr->out_file[svPtr->io]==NULL)
            ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
        fprintf(svPtr->out_file[svPtr->io], "\n");
        svPtr->hor[svPtr->io]=0;
        svPtr->ver[svPtr->io]++;
        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                         "*Time used: ");
        strcpy((char *) &gtmp[1],(const char *) "$zd1");
        zfcn(gtmp,tmp0,svPtr);
        if (sym_(SYMGET, (UNS) "time0", (UNS) tmp1, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "time0"); // not found
        sub((char *) tmp0,(char *) tmp1,(char *) tmp2);
        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                         tmp2);
        svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                         " seconds");
        fprintf(svPtr->out_file[svPtr->io], "\n");
        svPtr->hor[svPtr->io]=0;
        svPtr->ver[svPtr->io]++;

//=================================================================================
        svPtr->LineNumber=104; //  halt
//=================================================================================

//--------------
//       Halt
//--------------

        goto _epilogue;

//=================================================================================
//	Entry Point stems(ws) + + + + + + +

//=================================================================================
stems:
        svPtr->start[svPtr->_Sym] = NULL;
        _SymPush++;
        if (svPtr->_Sym > SYM_MAX) ErrorMessage("Too many function calls",svPtr->LineNumber);
        _doStackN[_doStx-1]=1; // flag to restore namespace
        if (__Arg0!=NULL) sym_(100, (UNS) "ws", (UNS) __Arg0,svPtr); // Store Arguments EP1003
        strcpy (svPtr->RefParm[0], "ws" ); // EP1004
        if (_ArgCount < 1) ErrorMessage("Bad argument count", svPtr->LineNumber);

//=================================================================================
        svPtr->LineNumber=106; // stems(ws)
//=================================================================================

//=================================================================================
        svPtr->LineNumber=107; //  for w3=$order(^stem(ws,w3)) write:$x>60 ?26 write w3," "
//=================================================================================

//--------------
//       For
//--------------

        strcpy(for21_lim, "");
        sym_(SYMSTORE, (UNS) "w3", (UNS) "", svPtr); // init $ case 2518

For_Group21: // m2522

//	m2525
        strmove((UNS) tmp2, (UNS) "^stem\x01"); // init p674
        if (sym_(SYMGET, (UNS) "ws", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "ws"); // not found
        strcatx((UNS) tmp2, (UNS) tmp0);
        if (sym_(SYMGET, (UNS) "w3", (UNS) tmp1, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "w3"); // not found
        strcatx((UNS) tmp2, (UNS) tmp1);
        GlobalOrder((unsigned char *) tmp2, (unsigned char *) tmp3,
                    (unsigned char *) NULL, svPtr); // p2236
        sym_(SYMSTORE, (UNS) "w3", (UNS) tmp3, svPtr); // set loop variable m2752
        if (strlen( (const char *) tmp3) == 0 ) goto For21Exit; // exit if empty 2758
        if ( setjmp( for21J ) == 0 ) goto For21;
        goto For_Group21; // m2771
        goto For21Exit; // bypass block

For21: // for loop body entry point B

        do { // for loop body
            svPtr->LineNumber = 107;
            sprintf((char *) tmp4,"%d",svPtr->hor[svPtr->io]); /* $x */
            if (numcomp1((UNS) tmp4, 60) > 0) strmove((UNS) tmp5, (UNS) "1");
            else strmove((UNS) tmp5, (UNS) "0");
            if (atoi( CSTR tmp5)) { // m859 postconditional

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                _Column(&svPtr->hor[svPtr->io], &svPtr->ver[svPtr->io],
                        "26", svPtr->out_file[svPtr->io]); // tab operator
                } /* post conditional 4092*/

//--------------
//       Write
//--------------

            if (svPtr->out_file[svPtr->io]==NULL)
                ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
            if (sym_(SYMGET, (UNS) "w3", (UNS) tmp6, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "w3"); // not found
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             tmp6);
            svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                             " ");
            }
        while (0);
        longjmp(for21J, _i); // FOR loop 1 close

For21Exit: ; // exit for loop


//=================================================================================
        svPtr->LineNumber=108; //  quit
//=================================================================================

//--------------
//       Quit
//--------------

        if (svPtr->Rargsx) { // call-by-reference?
            int i;
            unsigned char *tmp = new unsigned char[STR_MAX];
            for (i = 0; i < svPtr->Rargsx; i++) {
                sym_(1, (UNS) svPtr->RefParm[i], (UNS) tmp,svPtr);
                sym_(SYMSTORE, (UNS) svPtr->Rargs[i], (UNS) tmp, svPtr);
                }
            }
        strmove((UNS) _ReturnVal, (UNS) "");
        if (_doStackN[_doStx]) {
            _doStackN[_doStx] = 0;    // Q1001
            }
        if (_doStx > 0) {
            longjmp(_doStack[_doStx],99);
            }
        else ErrorMessage("Too Many Quits", svPtr->LineNumber);

//=================================================================================
_epilogue:
        tmp0[0]=0;
        tmp1[0]=0;  /*  Function Epilogue */
        Mltoa(getpid(),atmp);
        if (svPtr->LockDone) cleanLocks((char *) atmp);
        Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */

        } // end of try block

    catch(...) {
        if (GlobalExceptionCode == INPUT_ERROR) cout << "Input Error" << endl;
        else if (GlobalExceptionCode == INPUT_LENGTH) cout << "Input Length Error" << endl;
        else if (GlobalExceptionCode == SYMTAB_ERROR) cout << "Symbol Table Error" << endl;
        else if (GlobalExceptionCode == GLOBAL_NOT_FOUND) cout << "Global Not Found Error" << endl;
        else if (GlobalExceptionCode == INTERPRETER_ERROR) cout << "Interprerer Error" << endl;
        else if (GlobalExceptionCode == INVALID_CONVERSION) cout << "Invalid Conversion Error" << endl;
        else if (GlobalExceptionCode == DATA_RANGE_ERROR) cout << "Data Range Error" << endl;
        else if (GlobalExceptionCode == NUMERIC_RANGE) cout << "Numeric Range Error" << endl;
        else if (GlobalExceptionCode == UNSPECIFIED) cout << "Unspecified Error" << endl;
        cout << "Uncaught error in or near line "
             << svPtr->LineNumber << endl;
        Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */
        }

    return EXIT_SUCCESS;
    }  /* Terminate */
//=================================================================================


int _label_lookup(char *label) {
    return -1;
    }
const char * _text_function(int disp) {
    return NULL;
    }

