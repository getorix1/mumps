
// ==============================================================
//#+ This module generated by Mumps Compiler @VERSION@ Jun 27 2022
//#+  
//#+ Portions of this code are part of the Mumps Compiler
//#+ 
//#+ Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 
//#+ 2010, 2017, 2020, 2022 by Kevin C. O'Kane  
//#+ 
//#+ Kevin C. O'Kane, Ph.D.
//#+ Professor Emeritus
//#+ Computer Science Department
//#+ University of Northern Iowa
//#+ Cedar Falls, IA 50614-0507
//#+ kc.okane@gmail.com
//#+ https://threadsafebooks.com
//#+ https://www.cs.uni.edu/~okane
//#+ -----------------------------------
//#+ 
//#+ Consult individual modules for copyright details
//#+ The runtime libraries are covered by the following license:
//#+  
//#+ This library is free software; you can redistribute it and/or
//#+ modify it under the terms of the GNU Lesser General Public
//#+ License as published by the Free Software Foundation; either
//#+ version 2.1 of the License, or (at your option) any later version.
//#+ 
//#+ This library is distributed in the hope that it will be useful,
//#+ but WITHOUT ANY WARRANTY; without even the implied warranty of
//#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//#+ Lesser General Public License for more details.
//#+ 
//#+ You should have received a copy of the GNU Lesser General Public
//#+ License along with this library; if not, write to the Free Software
//#+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#+ 
//#+ This code is unverified - use at your own risk 
//#+==============================================================

#undef _MDH_
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <mumpsc/inline.h>
#include <mumpsc/defines.h>
#include <mumpsc/strmax.h>
#include <mumpsc/libmpscpp.h>
#include <mumpsc/sym.h>
#include <mumpsc/builtin.h>
#include <mumpsc/compiler.h>
#define FORPARM STR_MAX  /* Size of For loop parameter */
#define CSTR (char *)
#define USTR unsigned char *
#define CCHR const char *
#include <mumpsc/keyfix.h>
#include <mumpsc/globalOrder.h>
#include <mumpsc/stateVector.h>
int (*__label_lookup)(char *);
char * (*__text_function)(int);
void fcn(MSV *);
void zfcn(unsigned char *, unsigned char *, struct MSV *); /* z functions */
char * sym_(int, unsigned char *, unsigned char *, struct MSV *); /* symbol table */
char * makeLock(char *, char *, char *, char, char *); /* global array lock service */
char * cleanLocks(char *); /* global array lock service */
char * releaseLock(char *, char *, char *); /* global array lock service */
char * eraseLocks(char *); /* global array lock service */
void add(const char *a,const char *b,char *c); /* math function */
void sub(const char *a,const char *b,char *c); /* math function */
void mult(const char *a,const char *b,char *c); /* math function */
void divx(const char *a,const char *b,char *c); /* math function */
void divi(const char *a,const char *b,char *c); /* math function */
void _fnumber(unsigned char *,unsigned char *,
       unsigned char *,unsigned char *, MSV *); /* math function */
int DBSem = 0; /* deadlock prevention */
void SyncClock() {
    DBSem = 1;
    }
unsigned int set_alarm (unsigned int seconds) {
    struct itimerval old, xnew;
    xnew.it_interval.tv_usec = 0;
    xnew.it_interval.tv_sec = 0 ; // interval between alarms
    xnew.it_value.tv_usec = 0;
    xnew.it_value.tv_sec = (long int) 0;
    if (setitimer (ITIMER_REAL, &xnew, &old) < 0)
        return 0;
    else
        return old.it_value.tv_sec;
    }
#include <mumpsc/global.h>  /* Global array definitions */
  /* Interface to Mglobal(): */
  /* g = command */
  /* key = key sought or stored */
  /* bd = value returned or stored */
  /* svPtr = address of state vector */
#ifndef SUB
#include <mumpsc/fcns.h>  /* System support functions */
#include <mumpsc/sysfunc.h>  /* Many common global variables */
#endif
 // ===============================================================
 // +
 // + Kevin C. O'Kane, Ph.D.
 // + Professor Emeritus
 // + Computer Science Department
 // + University of Northern Iowa
 // + Cedar Falls, IA 50614-0507
 // + kc.okane@gmail.com
 // + okane@uni.edu
 // + https://threadsafebooks.com
 // + https://www.cs.uni.edu/~okane
 // +
 // +==============================================================
//================================================================================= 
//  zmain 
//================================================================================= 

int main(int argc, char *argv[]) {

//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#+ Intermediate temporary variables used during execution of string expressions
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

char *_ftmp = new char[STR_MAX]; /* intermediate temp */
/*** Temporary variables */
char for1_incr[FORPARM],for1_lim[FORPARM],for1_init[FORPARM];
int for1F; int for1T; long for1; double for1D;
char for2_incr[FORPARM],for2_lim[FORPARM],for2_init[FORPARM];
int for2F; int for2T; long for2; double for2D;
char for3_incr[FORPARM],for3_lim[FORPARM],for3_init[FORPARM];
int for3F; int for3T; long for3; double for3D;
char for4_incr[FORPARM],for4_lim[FORPARM],for4_init[FORPARM];
int for4F; int for4T; long for4; double for4D;
char for5_incr[FORPARM],for5_lim[FORPARM],for5_init[FORPARM];
int for5F; int for5T; long for5; double for5D;
char for6_incr[FORPARM],for6_lim[FORPARM],for6_init[FORPARM];
int for6F; int for6T; long for6; double for6D;
char for7_incr[FORPARM],for7_lim[FORPARM],for7_init[FORPARM];
int for7F; int for7T; long for7; double for7D;
char for8_incr[FORPARM],for8_lim[FORPARM],for8_init[FORPARM];
int for8F; int for8T; long for8; double for8D;
char for9_incr[FORPARM],for9_lim[FORPARM],for9_init[FORPARM];
int for9F; int for9T; long for9; double for9D;
char for10_incr[FORPARM],for10_lim[FORPARM],for10_init[FORPARM];
int for10F; int for10T; long for10; double for10D;
char for11_incr[FORPARM],for11_lim[FORPARM],for11_init[FORPARM];
int for11F; int for11T; long for11; double for11D;
char for12_incr[FORPARM],for12_lim[FORPARM],for12_init[FORPARM];
int for12F; int for12T; long for12; double for12D;
char for13_incr[FORPARM],for13_lim[FORPARM],for13_init[FORPARM];
int for13F; int for13T; long for13; double for13D;
char for14_incr[FORPARM],for14_lim[FORPARM],for14_init[FORPARM];
int for14F; int for14T; long for14; double for14D;
char for15_incr[FORPARM],for15_lim[FORPARM],for15_init[FORPARM];
int for15F; int for15T; long for15; double for15D;
char for16_incr[FORPARM],for16_lim[FORPARM],for16_init[FORPARM];
int for16F; int for16T; long for16; double for16D;
char for17_incr[FORPARM],for17_lim[FORPARM],for17_init[FORPARM];
int for17F; int for17T; long for17; double for17D;
char for18_incr[FORPARM],for18_lim[FORPARM],for18_init[FORPARM];
int for18F; int for18T; long for18; double for18D;
char for19_incr[FORPARM],for19_lim[FORPARM],for19_init[FORPARM];
int for19F; int for19T; long for19; double for19D;
char for20_incr[FORPARM],for20_lim[FORPARM],for20_init[FORPARM];
int for20F; int for20T; long for20; double for20D;
char for21_incr[FORPARM],for21_lim[FORPARM],for21_init[FORPARM];
int for21F; int for21T; long for21; double for21D;
char for22_incr[FORPARM],for22_lim[FORPARM],for22_init[FORPARM];
int for22F; int for22T; long for22; double for22D;
char for23_incr[FORPARM],for23_lim[FORPARM],for23_init[FORPARM];
int for23F; int for23T; long for23; double for23D;
char for24_incr[FORPARM],for24_lim[FORPARM],for24_init[FORPARM];
int for24F; int for24T; long for24; double for24D;
char for25_incr[FORPARM],for25_lim[FORPARM],for25_init[FORPARM];
int for25F; int for25T; long for25; double for25D;
char for26_incr[FORPARM],for26_lim[FORPARM],for26_init[FORPARM];
int for26F; int for26T; long for26; double for26D;
jmp_buf for0J;
jmp_buf for1J;
jmp_buf for2J;
jmp_buf for3J;
jmp_buf for4J;
jmp_buf for5J;
jmp_buf for6J;
jmp_buf for7J;
jmp_buf for8J;
jmp_buf for9J;
jmp_buf for10J;
jmp_buf for11J;
jmp_buf for12J;
jmp_buf for13J;
jmp_buf for14J;
jmp_buf for15J;
jmp_buf for16J;
jmp_buf for17J;
jmp_buf for18J;
jmp_buf for19J;
jmp_buf for20J;
jmp_buf for21J;
jmp_buf for22J;
jmp_buf for23J;
jmp_buf for24J;
jmp_buf for25J;
jmp_buf for26J;
jmp_buf Efor0J;
int tpx0;
jmp_buf Efor1J;
int tpx1;
jmp_buf Efor2J;
int tpx2;
jmp_buf Efor3J;
int tpx3;
jmp_buf Efor4J;
int tpx4;
jmp_buf Efor5J;
int tpx5;
jmp_buf Efor6J;
int tpx6;
jmp_buf Efor7J;
int tpx7;
jmp_buf Efor8J;
int tpx8;
jmp_buf Efor9J;
int tpx9;
jmp_buf Efor10J;
int tpx10;
jmp_buf Efor11J;
int tpx11;
unsigned char *tmp0 = new unsigned char[STR_MAX];
unsigned char *tmp1 = new unsigned char[STR_MAX];
unsigned char *tmp2 = new unsigned char[STR_MAX];
unsigned char *tmp3 = new unsigned char[STR_MAX];
unsigned char *tmp4 = new unsigned char[STR_MAX];
unsigned char *tmp5 = new unsigned char[STR_MAX];
unsigned char *tmp6 = new unsigned char[STR_MAX];
unsigned char *tmp7 = new unsigned char[STR_MAX];
unsigned char *tmp8 = new unsigned char[STR_MAX];
unsigned char *tmp9 = new unsigned char[STR_MAX];
unsigned char *tmp10 = new unsigned char[STR_MAX];
unsigned char *tmp11 = new unsigned char[STR_MAX];
unsigned char *tmp12 = new unsigned char[STR_MAX];
unsigned char *tmp13 = new unsigned char[STR_MAX];
unsigned char *tmp14 = new unsigned char[STR_MAX];
unsigned char *tmp15 = new unsigned char[STR_MAX];
unsigned char *tmp16 = new unsigned char[STR_MAX];
unsigned char *tmp17 = new unsigned char[STR_MAX];
unsigned char *tmp18 = new unsigned char[STR_MAX];
unsigned char *tmp19 = new unsigned char[STR_MAX];
unsigned char *tmp20 = new unsigned char[STR_MAX];
unsigned char *tmp21 = new unsigned char[STR_MAX];
unsigned char *tmp22 = new unsigned char[STR_MAX];
unsigned char *tmp23 = new unsigned char[STR_MAX];
unsigned char *tmp24 = new unsigned char[STR_MAX];
unsigned char *tmp25 = new unsigned char[STR_MAX];
unsigned char *tmp26 = new unsigned char[STR_MAX];
unsigned char *tmp27 = new unsigned char[STR_MAX];
unsigned char *tmp28 = new unsigned char[STR_MAX];
unsigned char *tmp29 = new unsigned char[STR_MAX];
unsigned char *tmp30 = new unsigned char[STR_MAX];
unsigned char *tmp31 = new unsigned char[STR_MAX];
unsigned char *tmp32 = new unsigned char[STR_MAX];
unsigned char *tmp33 = new unsigned char[STR_MAX];
unsigned char *tmp34 = new unsigned char[STR_MAX];
unsigned char *_dummy = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *atmp =new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *xgtmp = new unsigned char [STR_MAX]; /* temporary variable */
unsigned char *gtmpL = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *tmp = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *gtmp = new unsigned char [2*STR_MAX]; /* temporary variable */
int _label_lookup(char *); /* resolution of labels */
char * _text_function(int);
static unsigned char _ReturnVal[STR_MAX]; /* function returns */
int _ArgCount=0; /* Nbr of args to extrinsic */
long _i,_jj,_j,_k,_new;
int _SymPush=0,f=0;
int g=0;
jmp_buf _doStack[128]; /* <do> return stack mechanism */
short   _doStackN[128]={0}; /* <do> return stack mechanism */
static int     _doStx=0; /* <do> return stack mechanism */
char _Refs[10][32];
int _Refsx=0;

if (svPtr == NULL) svPtr = AllocSV();

_SymPush=0; // zap pushed tables 

svPtr->in_file[5]=stdin; // console default/
svPtr->out_file[5]=stdout; // console default

strcpy(svPtr->UDAT,"data.dat");
strcpy(svPtr->UKEY,"key.dat");

if ( 0) { // no alarm if slice is zero
	signal(SIGALRM, SyncClock);
	set_alarm(1);
	}

__label_lookup = _label_lookup;
__text_function = _text_function;

$SymPut("%",argv[0]); 

if (argc > 0) { 
	for (int i = 0; i < argc; i++) { 
		char t[STR_MAX]; 
		sprintf(t,"%%%d", i); 
		$SymPut(t, argv[i]); 
		} 
	} 

try { 
//================================================================================= 
svPtr->LineNumber=17; //  read "n ",n 
//================================================================================= 
	if (svPtr->in_file[svPtr->io] == NULL) 
		ErrorMessage("Read from input file", svPtr->LineNumber); 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"n ");
	svPtr->tpx=getstr1(svPtr->in_file[svPtr->io],&gtmp); // Read string into gtmp
	if (svPtr->tpx>=0) svPtr->tpx=1; else svPtr->tpx=0; // Set $Test
	sym_(0, (USTR) "n", (USTR) gtmp, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=19; //  for i=1:1:n do 
//================================================================================= 
	strmove((USTR) for1_init, (USTR) "1");
	strmove( (USTR) for1_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for1_lim, (USTR) tmp0);
	if (strchr((char *) for1_incr,'.')) { 
		for1D=atof(for1_incr);
		for1F=for1D<0.0 ? 1 : 0;
		for1T=1;
		}
	else { 
		for1=atol(for1_incr); 
		for1F=for1<0 ? 1 : 0;
		for1T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for1_init, svPtr); // init loop variable

	for1F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for1_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for1_lim) <= 0; /* LE limit value */

	for1T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for1D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for1, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for1J)==0) goto For1; // else continue

	goto For1Exit; // bypass block 

For1: // for loop entry point

	do { 
	svPtr->LineNumber=19; 
		tpx0=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor0J)==0) goto Do_Block_Entry0; //else continue 
		svPtr->tpx=tpx0; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for1J,99); // FOR loop 1 close 

For1Exit: ; // exit for loop 

	goto Do_Block_Bypass0; // C3551 bypass indented group

Do_Block_Entry0:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=20; //  . write "p",i," " 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"p");
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
//================================================================================= 
svPtr->LineNumber=21; //  . read p(i) 
//================================================================================= 
	if (svPtr->in_file[svPtr->io] == NULL) 
		ErrorMessage("Read from input file", svPtr->LineNumber); 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "p"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	svPtr->tpx=getstr1(svPtr->in_file[svPtr->io],&gtmp); // Read string into gtmp
	if (svPtr->tpx>=0) svPtr->tpx=1; else svPtr->tpx=0; // Set $Test
	sym_(0, (USTR) atmp, (USTR) gtmp, svPtr); // Store result 
	} while(0); // dotted un-indent 0 
	longjmp(Efor0J,99); // return 

Do_Block_Bypass0: ; //B848 

//================================================================================= 
svPtr->LineNumber=23; //  for i=0:1:n do 
//================================================================================= 
	strmove((USTR) for3_init, (USTR) "0");
	strmove( (USTR) for3_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for3_lim, (USTR) tmp0);
	if (strchr((char *) for3_incr,'.')) { 
		for3D=atof(for3_incr);
		for3F=for3D<0.0 ? 1 : 0;
		for3T=1;
		}
	else { 
		for3=atol(for3_incr); 
		for3F=for3<0 ? 1 : 0;
		for3T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for3_init, svPtr); // init loop variable

	for3F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for3_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for3_lim) <= 0; /* LE limit value */

	for3T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for3D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for3, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for3J)==0) goto For3; // else continue

	goto For3Exit; // bypass block 

For3: // for loop entry point

	do { 
	svPtr->LineNumber=23; 
		tpx1=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor1J)==0) goto Do_Block_Entry1; //else continue 
		svPtr->tpx=tpx1; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for3J,99); // FOR loop 1 close 

For3Exit: ; // exit for loop 

	goto Do_Block_Bypass1; // C3551 bypass indented group

Do_Block_Entry1:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=24; //  . write "q",i," " 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"q");
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
//================================================================================= 
svPtr->LineNumber=25; //  . read q(i) 
//================================================================================= 
	if (svPtr->in_file[svPtr->io] == NULL) 
		ErrorMessage("Read from input file", svPtr->LineNumber); 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "q"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	svPtr->tpx=getstr1(svPtr->in_file[svPtr->io],&gtmp); // Read string into gtmp
	if (svPtr->tpx>=0) svPtr->tpx=1; else svPtr->tpx=0; // Set $Test
	sym_(0, (USTR) atmp, (USTR) gtmp, svPtr); // Store result 
	} while(0); // dotted un-indent 0 
	longjmp(Efor1J,99); // return 

Do_Block_Bypass1: ; //B848 

//================================================================================= 
svPtr->LineNumber=27; //  for i=0:1:n do 
//================================================================================= 
	strmove((USTR) for5_init, (USTR) "0");
	strmove( (USTR) for5_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for5_lim, (USTR) tmp0);
	if (strchr((char *) for5_incr,'.')) { 
		for5D=atof(for5_incr);
		for5F=for5D<0.0 ? 1 : 0;
		for5T=1;
		}
	else { 
		for5=atol(for5_incr); 
		for5F=for5<0 ? 1 : 0;
		for5T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for5_init, svPtr); // init loop variable

	for5F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for5_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for5_lim) <= 0; /* LE limit value */

	for5T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for5D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for5, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for5J)==0) goto For5; // else continue

	goto For5Exit; // bypass block 

For5: // for loop entry point

	do { 
	svPtr->LineNumber=27; 
		tpx2=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor2J)==0) goto Do_Block_Entry2; //else continue 
		svPtr->tpx=tpx2; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for5J,99); // FOR loop 1 close 

For5Exit: ; // exit for loop 

	goto Do_Block_Bypass2; // C3551 bypass indented group

Do_Block_Entry2:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=28; //  . for j=0:1:n do 
//================================================================================= 
	strmove((USTR) for7_init, (USTR) "0");
	strmove( (USTR) for7_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for7_lim, (USTR) tmp0);
	if (strchr((char *) for7_incr,'.')) { 
		for7D=atof(for7_incr);
		for7F=for7D<0.0 ? 1 : 0;
		for7T=1;
		}
	else { 
		for7=atol(for7_incr); 
		for7F=for7<0 ? 1 : 0;
		for7T=0;
		} /* increment */

	for ( sym_(0, (USTR) "j", (USTR) for7_init, svPtr); // init loop variable

	for7F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "j", _dummy, svPtr),
	(USTR) for7_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "j", _dummy,svPtr),
	(USTR) for7_lim) <= 0; /* LE limit value */

	for7T ? /* increment */
	add3( sym_(11, (USTR) "j", _dummy, svPtr), for7D, (char *) _dummy),
	sym_(0,(USTR) "j",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "j", _dummy, svPtr), for7, (char *) _dummy),
	sym_(0,(USTR) "j", _dummy,svPtr))

	if (setjmp(for7J)==0) goto For7; // else continue

	goto For7Exit; // bypass block 

For7: // for loop entry point

	do { 
	svPtr->LineNumber=28; 
		tpx3=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor3J)==0) goto Do_Block_Entry3; //else continue 
		svPtr->tpx=tpx3; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for7J,99); // FOR loop 1 close 

For7Exit: ; // exit for loop 

	goto Do_Block_Bypass3; // C3551 bypass indented group

Do_Block_Entry3:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=29; //  .. set r(i,j)=0 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "r"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "j", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
		strcat((char *) tmp,(char *) tmp1); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	sym_(0, (USTR) atmp, (USTR) "0", svPtr); // Store result 
	} while(0); // dotted un-indent 1 
	longjmp(Efor3J,99); // return 

Do_Block_Bypass3: ; //B848 

	} while(0); // dotted un-indent 0 
	longjmp(Efor2J,99); // return 

Do_Block_Bypass2: ; //B848 

//================================================================================= 
svPtr->LineNumber=31; //  for i=0:1:n do 
//================================================================================= 
	strmove((USTR) for9_init, (USTR) "0");
	strmove( (USTR) for9_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for9_lim, (USTR) tmp0);
	if (strchr((char *) for9_incr,'.')) { 
		for9D=atof(for9_incr);
		for9F=for9D<0.0 ? 1 : 0;
		for9T=1;
		}
	else { 
		for9=atol(for9_incr); 
		for9F=for9<0 ? 1 : 0;
		for9T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for9_init, svPtr); // init loop variable

	for9F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for9_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for9_lim) <= 0; /* LE limit value */

	for9T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for9D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for9, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for9J)==0) goto For9; // else continue

	goto For9Exit; // bypass block 

For9: // for loop entry point

	do { 
	svPtr->LineNumber=31; 
		tpx4=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor4J)==0) goto Do_Block_Entry4; //else continue 
		svPtr->tpx=tpx4; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for9J,99); // FOR loop 1 close 

For9Exit: ; // exit for loop 

	goto Do_Block_Bypass4; // C3551 bypass indented group

Do_Block_Entry4:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=32; //  . set c(i,i)=0,w(i,i)=q(i) 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "c"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
		strcat((char *) tmp,(char *) tmp1); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	sym_(0, (USTR) atmp, (USTR) "0", svPtr); // Store result 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "w"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp3, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp3); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
		strcat((char *) tmp,(char *) tmp4); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
{ // local array setup
	int i;
	strmove((USTR) tmp7, (USTR) "q");
	i=strlen((const char *) tmp7);
	tmp7[i]=206;
	tmp7[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp7,(char *) tmp6);
	i=strlen((const char *) tmp7);
	tmp7[i]=207;
	tmp7[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp7, (USTR) tmp8, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp7);
	sym_(0, (USTR) atmp, (USTR) tmp8, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=33; //  . for j=i+1:1:n do 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	add( (char *) tmp0, "1", (char *) tmp1 ); 
	strmove((USTR) for11_init, (USTR) tmp1);
	strmove( (USTR) for11_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for11_lim, (USTR) tmp2);
	if (strchr((char *) for11_incr,'.')) { 
		for11D=atof(for11_incr);
		for11F=for11D<0.0 ? 1 : 0;
		for11T=1;
		}
	else { 
		for11=atol(for11_incr); 
		for11F=for11<0 ? 1 : 0;
		for11T=0;
		} /* increment */

	for ( sym_(0, (USTR) "j", (USTR) for11_init, svPtr); // init loop variable

	for11F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "j", _dummy, svPtr),
	(USTR) for11_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "j", _dummy,svPtr),
	(USTR) for11_lim) <= 0; /* LE limit value */

	for11T ? /* increment */
	add3( sym_(11, (USTR) "j", _dummy, svPtr), for11D, (char *) _dummy),
	sym_(0,(USTR) "j",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "j", _dummy, svPtr), for11, (char *) _dummy),
	sym_(0,(USTR) "j", _dummy,svPtr))

	if (setjmp(for11J)==0) goto For11; // else continue

	goto For11Exit; // bypass block 

For11: // for loop entry point

	do { 
	svPtr->LineNumber=33; 
		tpx5=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor5J)==0) goto Do_Block_Entry5; //else continue 
		svPtr->tpx=tpx5; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for11J,99); // FOR loop 1 close 

For11Exit: ; // exit for loop 

	goto Do_Block_Bypass5; // C3551 bypass indented group

Do_Block_Entry5:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=34; //  .. set:j'>n w(i,j)=w(i,j-1)+p(j)+q(j) 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	if (numcomp((USTR) tmp0, (USTR) tmp1) <= 0) strmove((USTR) tmp2, (USTR) "1");
	else strmove((USTR) tmp2, (USTR) "0");
	if (atoi( CSTR tmp2)) { /* postconditional */
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "w"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp3, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp3); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "j", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
		strcat((char *) tmp,(char *) tmp4); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp7, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sub((char *) tmp7,(char *) "1",(char *) tmp8);
{ // local array setup
	int i;
	strmove((USTR) tmp9, (USTR) "w");
	i=strlen((const char *) tmp9);
	tmp9[i]=206;
	tmp9[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp9,(char *) tmp6);
	i=strlen((const char *) tmp9);
	tmp9[i]=208;
	tmp9[i+1]=0;
	strcat((char *) tmp9,(char *) tmp8);
	i=strlen((const char *) tmp9);
	tmp9[i]=207;
	tmp9[i+1]=0;
	}
{ // local array setup
	int i;
	strmove((USTR) tmp12, (USTR) "p");
	i=strlen((const char *) tmp12);
	tmp12[i]=206;
	tmp12[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp11, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp12,(char *) tmp11);
	i=strlen((const char *) tmp12);
	tmp12[i]=207;
	tmp12[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp9, (USTR) tmp10, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp9);
	if (sym_(SYMGET, (USTR) tmp12, (USTR) tmp13, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp12);
	add((char *) tmp10, (char *) tmp13, (char *) tmp14); 
{ // local array setup
	int i;
	strmove((USTR) tmp16, (USTR) "q");
	i=strlen((const char *) tmp16);
	tmp16[i]=206;
	tmp16[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp15, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp16,(char *) tmp15);
	i=strlen((const char *) tmp16);
	tmp16[i]=207;
	tmp16[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp16, (USTR) tmp17, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp16);
	add((char *) tmp14, (char *) tmp17, (char *) tmp18); 
	sym_(0, (USTR) atmp, (USTR) tmp18, svPtr); // Store result 
	} /* post conditional */
	} while(0); // dotted un-indent 1 
	longjmp(Efor5J,99); // return 

Do_Block_Bypass5: ; //B848 

	} while(0); // dotted un-indent 0 
	longjmp(Efor4J,99); // return 

Do_Block_Bypass4: ; //B848 

//================================================================================= 
svPtr->LineNumber=36; //  for j=1:1:n do 
//================================================================================= 
	strmove((USTR) for13_init, (USTR) "1");
	strmove( (USTR) for13_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for13_lim, (USTR) tmp0);
	if (strchr((char *) for13_incr,'.')) { 
		for13D=atof(for13_incr);
		for13F=for13D<0.0 ? 1 : 0;
		for13T=1;
		}
	else { 
		for13=atol(for13_incr); 
		for13F=for13<0 ? 1 : 0;
		for13T=0;
		} /* increment */

	for ( sym_(0, (USTR) "j", (USTR) for13_init, svPtr); // init loop variable

	for13F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "j", _dummy, svPtr),
	(USTR) for13_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "j", _dummy,svPtr),
	(USTR) for13_lim) <= 0; /* LE limit value */

	for13T ? /* increment */
	add3( sym_(11, (USTR) "j", _dummy, svPtr), for13D, (char *) _dummy),
	sym_(0,(USTR) "j",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "j", _dummy, svPtr), for13, (char *) _dummy),
	sym_(0,(USTR) "j", _dummy,svPtr))

	if (setjmp(for13J)==0) goto For13; // else continue

	goto For13Exit; // bypass block 

For13: // for loop entry point

	do { 
	svPtr->LineNumber=36; 
		tpx6=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor6J)==0) goto Do_Block_Entry6; //else continue 
		svPtr->tpx=tpx6; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for13J,99); // FOR loop 1 close 

For13Exit: ; // exit for loop 

	goto Do_Block_Bypass6; // C3551 bypass indented group

Do_Block_Entry6:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=37; //  . set c(j-1,j)=w(j-1,j),r(j-1,j)=j 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sub((char *) tmp0,(char *) "1",(char *) tmp1);
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "c"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
	strcat((char *) tmp,(char *) tmp1); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "j", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
		strcat((char *) tmp,(char *) tmp2); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sub((char *) tmp4,(char *) "1",(char *) tmp5);
{ // local array setup
	int i;
	strmove((USTR) tmp7, (USTR) "w");
	i=strlen((const char *) tmp7);
	tmp7[i]=206;
	tmp7[i+1]=0;
	strcat((char *) tmp7,(char *) tmp5);
	i=strlen((const char *) tmp7);
	tmp7[i]=208;
	tmp7[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp7,(char *) tmp6);
	i=strlen((const char *) tmp7);
	tmp7[i]=207;
	tmp7[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp7, (USTR) tmp8, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp7);
	sym_(0, (USTR) atmp, (USTR) tmp8, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp9, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sub((char *) tmp9,(char *) "1",(char *) tmp10);
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "r"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
	strcat((char *) tmp,(char *) tmp10); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "j", (USTR) tmp11, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
		strcat((char *) tmp,(char *) tmp11); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp13, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sym_(0, (USTR) atmp, (USTR) tmp13, svPtr); // Store result 
	} while(0); // dotted un-indent 0 
	longjmp(Efor6J,99); // return 

Do_Block_Bypass6: ; //B848 

//================================================================================= 
svPtr->LineNumber=39; //  for d=2:1:n do 
//================================================================================= 
	strmove((USTR) for15_init, (USTR) "2");
	strmove( (USTR) for15_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for15_lim, (USTR) tmp0);
	if (strchr((char *) for15_incr,'.')) { 
		for15D=atof(for15_incr);
		for15F=for15D<0.0 ? 1 : 0;
		for15T=1;
		}
	else { 
		for15=atol(for15_incr); 
		for15F=for15<0 ? 1 : 0;
		for15T=0;
		} /* increment */

	for ( sym_(0, (USTR) "d", (USTR) for15_init, svPtr); // init loop variable

	for15F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "d", _dummy, svPtr),
	(USTR) for15_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "d", _dummy,svPtr),
	(USTR) for15_lim) <= 0; /* LE limit value */

	for15T ? /* increment */
	add3( sym_(11, (USTR) "d", _dummy, svPtr), for15D, (char *) _dummy),
	sym_(0,(USTR) "d",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "d", _dummy, svPtr), for15, (char *) _dummy),
	sym_(0,(USTR) "d", _dummy,svPtr))

	if (setjmp(for15J)==0) goto For15; // else continue

	goto For15Exit; // bypass block 

For15: // for loop entry point

	do { 
	svPtr->LineNumber=39; 
		tpx7=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor7J)==0) goto Do_Block_Entry7; //else continue 
		svPtr->tpx=tpx7; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for15J,99); // FOR loop 1 close 

For15Exit: ; // exit for loop 

	goto Do_Block_Bypass7; // C3551 bypass indented group

Do_Block_Entry7:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=40; //  . for j=d:1:n do 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "d", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "d");
	strmove((USTR) for17_init, (USTR) tmp0);
	strmove( (USTR) for17_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for17_lim, (USTR) tmp1);
	if (strchr((char *) for17_incr,'.')) { 
		for17D=atof(for17_incr);
		for17F=for17D<0.0 ? 1 : 0;
		for17T=1;
		}
	else { 
		for17=atol(for17_incr); 
		for17F=for17<0 ? 1 : 0;
		for17T=0;
		} /* increment */

	for ( sym_(0, (USTR) "j", (USTR) for17_init, svPtr); // init loop variable

	for17F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "j", _dummy, svPtr),
	(USTR) for17_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "j", _dummy,svPtr),
	(USTR) for17_lim) <= 0; /* LE limit value */

	for17T ? /* increment */
	add3( sym_(11, (USTR) "j", _dummy, svPtr), for17D, (char *) _dummy),
	sym_(0,(USTR) "j",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "j", _dummy, svPtr), for17, (char *) _dummy),
	sym_(0,(USTR) "j", _dummy,svPtr))

	if (setjmp(for17J)==0) goto For17; // else continue

	goto For17Exit; // bypass block 

For17: // for loop entry point

	do { 
	svPtr->LineNumber=40; 
		tpx8=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor8J)==0) goto Do_Block_Entry8; //else continue 
		svPtr->tpx=tpx8; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for17J,99); // FOR loop 1 close 

For17Exit: ; // exit for loop 

	goto Do_Block_Bypass8; // C3551 bypass indented group

Do_Block_Entry8:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=41; //  .. set i=j-d,y=r(i,j-1),x=c(i,y-1)+c(y,j) 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	if (sym_(SYMGET, (USTR) "d", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "d");
	sub((char *) tmp1,(char *) tmp2,(char *) tmp3);
	sym_(0, (USTR) "i", (USTR) tmp3, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sub((char *) tmp6,(char *) "1",(char *) tmp7);
{ // local array setup
	int i;
	strmove((USTR) tmp8, (USTR) "r");
	i=strlen((const char *) tmp8);
	tmp8[i]=206;
	tmp8[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp5, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp8,(char *) tmp5);
	i=strlen((const char *) tmp8);
	tmp8[i]=208;
	tmp8[i+1]=0;
	strcat((char *) tmp8,(char *) tmp7);
	i=strlen((const char *) tmp8);
	tmp8[i]=207;
	tmp8[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp8, (USTR) tmp9, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp8);
	sym_(0, (USTR) "y", (USTR) tmp9, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "y", (USTR) tmp12, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "y");
	sub((char *) tmp12,(char *) "1",(char *) tmp13);
{ // local array setup
	int i;
	strmove((USTR) tmp14, (USTR) "c");
	i=strlen((const char *) tmp14);
	tmp14[i]=206;
	tmp14[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp11, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp14,(char *) tmp11);
	i=strlen((const char *) tmp14);
	tmp14[i]=208;
	tmp14[i+1]=0;
	strcat((char *) tmp14,(char *) tmp13);
	i=strlen((const char *) tmp14);
	tmp14[i]=207;
	tmp14[i+1]=0;
	}
{ // local array setup
	int i;
	strmove((USTR) tmp18, (USTR) "c");
	i=strlen((const char *) tmp18);
	tmp18[i]=206;
	tmp18[i+1]=0;
	if (sym_(SYMGET, (USTR) "y", (USTR) tmp16, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "y");
	strcat((char *) tmp18,(char *) tmp16);
	i=strlen((const char *) tmp18);
	tmp18[i]=208;
	tmp18[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp17, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp18,(char *) tmp17);
	i=strlen((const char *) tmp18);
	tmp18[i]=207;
	tmp18[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp14, (USTR) tmp15, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp14);
	if (sym_(SYMGET, (USTR) tmp18, (USTR) tmp19, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp18);
	add((char *) tmp15, (char *) tmp19, (char *) tmp20); 
	sym_(0, (USTR) "x", (USTR) tmp20, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=42; //  .. do xx 
//================================================================================= 
	_ArgCount=0;  //section D1000 
	svPtr->Rargsx=0;
	{
	 _ArgCount=0;
	 _doStx++;
	 if (_doStx > 127 ) ErrorMessage("Too many function calls",svPtr->LineNumber);
	 sym_(99, (unsigned char *) "", (unsigned char *) "", svPtr); 
	 if (setjmp(_doStack[_doStx])==0) goto xx;  /* Jump to function */
	 _doStx--; 
	 strmove((unsigned char *) tmp0,(unsigned char *) _ReturnVal); // Copy result
	} 
 //================================================================================= 
svPtr->LineNumber=43; //  .. set c(i,j)=w(i,j)+x,r(i,j)=y 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "c"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "j", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
		strcat((char *) tmp,(char *) tmp1); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
{ // local array setup
	int i;
	strmove((USTR) tmp5, (USTR) "w");
	i=strlen((const char *) tmp5);
	tmp5[i]=206;
	tmp5[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp3, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp5,(char *) tmp3);
	i=strlen((const char *) tmp5);
	tmp5[i]=208;
	tmp5[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp5,(char *) tmp4);
	i=strlen((const char *) tmp5);
	tmp5[i]=207;
	tmp5[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp5, (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp5);
	if (sym_(SYMGET, (USTR) "x", (USTR) tmp7, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "x");
	add((char *) tmp6, (char *) tmp7, (char *) tmp8); 
	sym_(0, (USTR) atmp, (USTR) tmp8, svPtr); // Store result 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "r"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp9, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp9); // index
		i=strlen(tmp);
		tmp[i]=208; // coded comma or close paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "j", (USTR) tmp10, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
		strcat((char *) tmp,(char *) tmp10); // index
		i=strlen((const char *) tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	if (sym_(SYMGET, (USTR) "y", (USTR) tmp12, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "y");
	sym_(0, (USTR) atmp, (USTR) tmp12, svPtr); // Store result 
	} while(0); // dotted un-indent 1 
	longjmp(Efor8J,99); // return 

Do_Block_Bypass8: ; //B848 

	} while(0); // dotted un-indent 0 
	longjmp(Efor7J,99); // return 

Do_Block_Bypass7: ; //B848 

//================================================================================= 
svPtr->LineNumber=45; //  write !,"matrix",! 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"matrix");
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
//================================================================================= 
svPtr->LineNumber=46; //  for m=0:1:n-1 do 
//================================================================================= 
	strmove((USTR) for19_init, (USTR) "0");
	strmove( (USTR) for19_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	sub((char *) tmp0,(char *) "1",(char *) tmp1);
	strmove((USTR) for19_lim, (USTR) tmp1);
	if (strchr((char *) for19_incr,'.')) { 
		for19D=atof(for19_incr);
		for19F=for19D<0.0 ? 1 : 0;
		for19T=1;
		}
	else { 
		for19=atol(for19_incr); 
		for19F=for19<0 ? 1 : 0;
		for19T=0;
		} /* increment */

	for ( sym_(0, (USTR) "m", (USTR) for19_init, svPtr); // init loop variable

	for19F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "m", _dummy, svPtr),
	(USTR) for19_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "m", _dummy,svPtr),
	(USTR) for19_lim) <= 0; /* LE limit value */

	for19T ? /* increment */
	add3( sym_(11, (USTR) "m", _dummy, svPtr), for19D, (char *) _dummy),
	sym_(0,(USTR) "m",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "m", _dummy, svPtr), for19, (char *) _dummy),
	sym_(0,(USTR) "m", _dummy,svPtr))

	if (setjmp(for19J)==0) goto For19; // else continue

	goto For19Exit; // bypass block 

For19: // for loop entry point

	do { 
	svPtr->LineNumber=46; 
		tpx9=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor9J)==0) goto Do_Block_Entry9; //else continue 
		svPtr->tpx=tpx9; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for19J,99); // FOR loop 1 close 

For19Exit: ; // exit for loop 

	goto Do_Block_Bypass9; // C3551 bypass indented group

Do_Block_Entry9:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=47; //  . write ! 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
//================================================================================= 
svPtr->LineNumber=48; //  . for l=1:1:n do 
//================================================================================= 
	strmove((USTR) for21_init, (USTR) "1");
	strmove( (USTR) for21_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	strmove((USTR) for21_lim, (USTR) tmp0);
	if (strchr((char *) for21_incr,'.')) { 
		for21D=atof(for21_incr);
		for21F=for21D<0.0 ? 1 : 0;
		for21T=1;
		}
	else { 
		for21=atol(for21_incr); 
		for21F=for21<0 ? 1 : 0;
		for21T=0;
		} /* increment */

	for ( sym_(0, (USTR) "l", (USTR) for21_init, svPtr); // init loop variable

	for21F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "l", _dummy, svPtr),
	(USTR) for21_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "l", _dummy,svPtr),
	(USTR) for21_lim) <= 0; /* LE limit value */

	for21T ? /* increment */
	add3( sym_(11, (USTR) "l", _dummy, svPtr), for21D, (char *) _dummy),
	sym_(0,(USTR) "l",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "l", _dummy, svPtr), for21, (char *) _dummy),
	sym_(0,(USTR) "l", _dummy,svPtr))

	if (setjmp(for21J)==0) goto For21; // else continue

	goto For21Exit; // bypass block 

For21: // for loop entry point

	do { 
	svPtr->LineNumber=48; 
		tpx10=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor10J)==0) goto Do_Block_Entry10; //else continue 
		svPtr->tpx=tpx10; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for21J,99); // FOR loop 1 close 

For21Exit: ; // exit for loop 

	goto Do_Block_Bypass10; // C3551 bypass indented group

Do_Block_Entry10:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=49; //  .. write r(m,l)," " 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
{ // local array setup
	int i;
	strmove((USTR) tmp2, (USTR) "r");
	i=strlen((const char *) tmp2);
	tmp2[i]=206;
	tmp2[i+1]=0;
	if (sym_(SYMGET, (USTR) "m", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "m");
	strcat((char *) tmp2,(char *) tmp0);
	i=strlen((const char *) tmp2);
	tmp2[i]=208;
	tmp2[i+1]=0;
	if (sym_(SYMGET, (USTR) "l", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "l");
	strcat((char *) tmp2,(char *) tmp1);
	i=strlen((const char *) tmp2);
	tmp2[i]=207;
	tmp2[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp2, (USTR) tmp3, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp2);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp3);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
	} while(0); // dotted un-indent 1 
	longjmp(Efor10J,99); // return 

Do_Block_Bypass10: ; //B848 

	} while(0); // dotted un-indent 0 
	longjmp(Efor9J,99); // return 

Do_Block_Bypass9: ; //B848 

//================================================================================= 
svPtr->LineNumber=51; //  write !! 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
//================================================================================= 
svPtr->LineNumber=52; //  set s=1 
//================================================================================= 
	sym_(0, (USTR) "s", (USTR) "1", svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=53; //  set s(s)=0_","_n 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "s"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "s", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "s");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	if (strlen((const char *) "0") + strlen((const char *) ",") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
	strmove( (USTR) tmp2, (USTR) "0");
	strcat( (char *) tmp2, (char *) ",");
	if (sym_(SYMGET, (USTR) "n", (USTR) tmp3, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "n");
	if (strlen((const char *) tmp2) + strlen((const char *) tmp3) + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
	strmove( (USTR) tmp4, (USTR) tmp2);
	strcat( (char *) tmp4, (char *) tmp3);
	sym_(0, (USTR) atmp, (USTR) tmp4, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=54; //  set c=1 
//================================================================================= 
	sym_(0, (USTR) "c", (USTR) "1", svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=55; //  set nx=2 
//================================================================================= 
	sym_(0, (USTR) "nx", (USTR) "2", svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=56; //  set a(1)="b(0" 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "a"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
	strcat((char *) tmp,(char *) "1"); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
	sym_(0, (USTR) atmp, (USTR) "b(0", svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=57; //  write 1 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"1");
//================================================================================= 
svPtr->LineNumber=59; // y if $p(s(c),",",1)-$p(s(c),",",2)=0 set c=c+1 goto:c<nx y goto z 
//================================================================================= 

y: 
{ // local array setup
	int i;
	strmove((USTR) tmp1, (USTR) "s");
	i=strlen((const char *) tmp1);
	tmp1[i]=206;
	tmp1[i+1]=0;
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	strcat((char *) tmp1,(char *) tmp0);
	i=strlen((const char *) tmp1);
	tmp1[i]=207;
	tmp1[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp1, (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp1);
	_piece((USTR) tmp3, 
		(USTR) tmp2,(USTR) ",",(USTR) "1", (USTR) "-1", 
		0, (USTR) "", svPtr); 
{ // local array setup
	int i;
	strmove((USTR) tmp5, (USTR) "s");
	i=strlen((const char *) tmp5);
	tmp5[i]=206;
	tmp5[i+1]=0;
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	strcat((char *) tmp5,(char *) tmp4);
	i=strlen((const char *) tmp5);
	tmp5[i]=207;
	tmp5[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp5, (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp5);
	_piece((USTR) tmp7, 
		(USTR) tmp6,(USTR) ",",(USTR) "2", (USTR) "-1", 
		0, (USTR) "", svPtr); 
	sub((char *) tmp3,(char *) tmp7,(char *) tmp8);
	if (strcmp((const char *) tmp8,(const char *) "0")==0) 
	strmove( (USTR) tmp9, (USTR) "1");
	else strmove( (USTR) tmp9, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp9, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp11, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	add( (char *) tmp11, "1", (char *) tmp12 ); 
	sym_(0, (USTR) "c", (USTR) tmp12, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp13, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	if (sym_(SYMGET, (USTR) "nx", (USTR) tmp14, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "nx");
	if (numcomp((USTR) tmp13, (USTR) tmp14) < 0) strmove((USTR) tmp15, (USTR) "1");
	else strmove((USTR) tmp15, (USTR) "0");
	if (atoi( CSTR tmp15)) { /* postconditional */
	goto y;
	} /* post conditional */
	goto z;
	} 
//================================================================================= 
svPtr->LineNumber=61; //  write 2," ",a(c)," " 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"2");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
{ // local array setup
	int i;
	strmove((USTR) tmp1, (USTR) "a");
	i=strlen((const char *) tmp1);
	tmp1[i]=206;
	tmp1[i+1]=0;
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	strcat((char *) tmp1,(char *) tmp0);
	i=strlen((const char *) tmp1);
	tmp1[i]=207;
	tmp1[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp1, (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp1);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp2);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
//================================================================================= 
svPtr->LineNumber=62; //  set s(nx)=$p(s(c),",",1)_","_(r(@s(c))-1) 
//================================================================================= 
	_jj = Interpret( (CCHR) 
		"s s(nx)=$p(s(c),\",\",1)_\",\"_(r(@s(c))-1)", svPtr); 
	svPtr->ERROR = _jj; 
	if (!svPtr->NOERR && _jj < 0) 
		ErrorMessage("Indirection error", svPtr->LineNumber); 
//================================================================================= 
svPtr->LineNumber=63; //  set a(nx)=a(c)_",1" 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "a"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "nx", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "nx");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
{ // local array setup
	int i;
	strmove((USTR) tmp3, (USTR) "a");
	i=strlen((const char *) tmp3);
	tmp3[i]=206;
	tmp3[i+1]=0;
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	strcat((char *) tmp3,(char *) tmp2);
	i=strlen((const char *) tmp3);
	tmp3[i]=207;
	tmp3[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp3, (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp3);
	if (strlen((const char *) tmp4) + strlen((const char *) ",1") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
	strmove( (USTR) tmp5, (USTR) tmp4);
	strcat( (char *) tmp5, (char *) ",1");
	sym_(0, (USTR) atmp, (USTR) tmp5, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=64; //  write 3 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"3");
//================================================================================= 
svPtr->LineNumber=65; //  set nx=nx+1 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "nx", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "nx");
	add( (char *) tmp1, "1", (char *) tmp2 ); 
	sym_(0, (USTR) "nx", (USTR) tmp2, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=66; //  set s(nx)=r(@s(c))_","_$p(s(c),",",2) 
//================================================================================= 
	_jj = Interpret( (CCHR) 
		"s s(nx)=r(@s(c))_\",\"_$p(s(c),\",\",2)", svPtr); 
	svPtr->ERROR = _jj; 
	if (!svPtr->NOERR && _jj < 0) 
		ErrorMessage("Indirection error", svPtr->LineNumber); 
//================================================================================= 
svPtr->LineNumber=67; //  set a(nx)=a(c)_",2" 
//================================================================================= 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "a"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "nx", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "nx");
	strcat((char *) tmp,(char *) tmp0); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
{ // local array setup
	int i;
	strmove((USTR) tmp3, (USTR) "a");
	i=strlen((const char *) tmp3);
	tmp3[i]=206;
	tmp3[i+1]=0;
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	strcat((char *) tmp3,(char *) tmp2);
	i=strlen((const char *) tmp3);
	tmp3[i]=207;
	tmp3[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp3, (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp3);
	if (strlen((const char *) tmp4) + strlen((const char *) ",2") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
	strmove( (USTR) tmp5, (USTR) tmp4);
	strcat( (char *) tmp5, (char *) ",2");
	sym_(0, (USTR) atmp, (USTR) tmp5, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=68; //  set nx=nx+1 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "nx", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "nx");
	add( (char *) tmp1, "1", (char *) tmp2 ); 
	sym_(0, (USTR) "nx", (USTR) tmp2, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=69; //  write 4 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		"4");
//================================================================================= 
svPtr->LineNumber=70; //  set c=c+1 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	add( (char *) tmp1, "1", (char *) tmp2 ); 
	sym_(0, (USTR) "c", (USTR) tmp2, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=71; //  goto y 
//================================================================================= 
	goto y;
//================================================================================= 
svPtr->LineNumber=73; // z for i=1:1:c-1 set a(i)=a(i)_")" 
//================================================================================= 

z: 
	strmove((USTR) for23_init, (USTR) "1");
	strmove( (USTR) for23_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	sub((char *) tmp0,(char *) "1",(char *) tmp1);
	strmove((USTR) for23_lim, (USTR) tmp1);
	if (strchr((char *) for23_incr,'.')) { 
		for23D=atof(for23_incr);
		for23F=for23D<0.0 ? 1 : 0;
		for23T=1;
		}
	else { 
		for23=atol(for23_incr); 
		for23F=for23<0 ? 1 : 0;
		for23T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for23_init, svPtr); // init loop variable

	for23F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for23_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for23_lim) <= 0; /* LE limit value */

	for23T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for23D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for23, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for23J)==0) goto For23; // else continue

	goto For23Exit; // bypass block 

For23: // for loop entry point

	do { 
	svPtr->LineNumber=73; 
	{	char tmp[STR_MAX];  // expand lhs array reference
		int i;
		strmove((USTR) tmp, (USTR) "a"); // array name
		i=strlen(tmp);
		tmp[i]=206; // coded open paren
		tmp[i+1]=0;
		if (sym_(SYMGET, (USTR) "i", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp,(char *) tmp2); // index
		i=strlen(tmp);
		tmp[i]=207; // coded comma or close paren
		tmp[i+1]=0;
	strmove((USTR) atmp, (USTR) tmp); // preserve expanded array reference
		}
{ // local array setup
	int i;
	strmove((USTR) tmp5, (USTR) "a");
	i=strlen((const char *) tmp5);
	tmp5[i]=206;
	tmp5[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp5,(char *) tmp4);
	i=strlen((const char *) tmp5);
	tmp5[i]=207;
	tmp5[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp5, (USTR) tmp6, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp5);
	if (strlen((const char *) tmp6) + strlen((const char *) ")") + 1 > STR_MAX) ErrorMessage("String too long",svPtr->LineNumber);
	strmove( (USTR) tmp7, (USTR) tmp6);
	strcat( (char *) tmp7, (char *) ")");
	sym_(0, (USTR) atmp, (USTR) tmp7, svPtr); // Store result 
	} while (0); longjmp(for23J,99); // FOR loop 1 close 

For23Exit: ; // exit for loop 

//================================================================================= 
svPtr->LineNumber=74; //  for i=1:1:c-1 set @a(i)=r(@s(i)) 
//================================================================================= 
	strmove((USTR) for24_init, (USTR) "1");
	strmove( (USTR) for24_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	sub((char *) tmp0,(char *) "1",(char *) tmp1);
	strmove((USTR) for24_lim, (USTR) tmp1);
	if (strchr((char *) for24_incr,'.')) { 
		for24D=atof(for24_incr);
		for24F=for24D<0.0 ? 1 : 0;
		for24T=1;
		}
	else { 
		for24=atol(for24_incr); 
		for24F=for24<0 ? 1 : 0;
		for24T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for24_init, svPtr); // init loop variable

	for24F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for24_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for24_lim) <= 0; /* LE limit value */

	for24T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for24D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for24, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for24J)==0) goto For24; // else continue

	goto For24Exit; // bypass block 

For24: // for loop entry point

	do { 
	svPtr->LineNumber=74; 
	_jj = Interpret( (CCHR) 
		"s @a(i)=r(@s(i))", svPtr); 
	svPtr->ERROR = _jj; 
	if (!svPtr->NOERR && _jj < 0) 
		ErrorMessage("Indirection error", svPtr->LineNumber); 
	} while (0); longjmp(for24J,99); // FOR loop 1 close 

For24Exit: ; // exit for loop 

//================================================================================= 
svPtr->LineNumber=75; //  for i=1:1:c-1 write !,a(i),"->",@a(i) 
//================================================================================= 
	strmove((USTR) for25_init, (USTR) "1");
	strmove( (USTR) for25_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "c", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "c");
	sub((char *) tmp0,(char *) "1",(char *) tmp1);
	strmove((USTR) for25_lim, (USTR) tmp1);
	if (strchr((char *) for25_incr,'.')) { 
		for25D=atof(for25_incr);
		for25F=for25D<0.0 ? 1 : 0;
		for25T=1;
		}
	else { 
		for25=atol(for25_incr); 
		for25F=for25<0 ? 1 : 0;
		for25T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for25_init, svPtr); // init loop variable

	for25F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "i", _dummy, svPtr),
	(USTR) for25_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "i", _dummy,svPtr),
	(USTR) for25_lim) <= 0; /* LE limit value */

	for25T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for25D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for25, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for25J)==0) goto For25; // else continue

	goto For25Exit; // bypass block 

For25: // for loop entry point

	do { 
	svPtr->LineNumber=75; 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	_jj = Interpret( (CCHR) 
		"w !,a(i),\"->\",@a(i)", svPtr); 
	svPtr->ERROR = _jj; 
	if (!svPtr->NOERR && _jj < 0) 
		ErrorMessage("Indirection error", svPtr->LineNumber); 
	} while (0); longjmp(for25J,99); // FOR loop 1 close 

For25Exit: ; // exit for loop 

//================================================================================= 
svPtr->LineNumber=76; //  halt 
//================================================================================= 
	goto _epilogue; 
//================================================================================= 
svPtr->LineNumber=78; // xx for k=r(i,j-1):1:r(i+1,j) i c(i,k-1)+c(k,j)<x set x=c(i,k-1)+c(k,j),y=k 
//================================================================================= 

xx: 
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	sub((char *) tmp1,(char *) "1",(char *) tmp2);
{ // local array setup
	int i;
	strmove((USTR) tmp3, (USTR) "r");
	i=strlen((const char *) tmp3);
	tmp3[i]=206;
	tmp3[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp3,(char *) tmp0);
	i=strlen((const char *) tmp3);
	tmp3[i]=208;
	tmp3[i+1]=0;
	strcat((char *) tmp3,(char *) tmp2);
	i=strlen((const char *) tmp3);
	tmp3[i]=207;
	tmp3[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp3, (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp3);
	strmove((USTR) for26_init, (USTR) tmp4);
	strmove( (USTR) for26_incr, (USTR) "1");
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp5, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	add( (char *) tmp5, "1", (char *) tmp6 ); 
{ // local array setup
	int i;
	strmove((USTR) tmp8, (USTR) "r");
	i=strlen((const char *) tmp8);
	tmp8[i]=206;
	tmp8[i+1]=0;
	strcat((char *) tmp8,(char *) tmp6);
	i=strlen((const char *) tmp8);
	tmp8[i]=208;
	tmp8[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp7, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp8,(char *) tmp7);
	i=strlen((const char *) tmp8);
	tmp8[i]=207;
	tmp8[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp8, (USTR) tmp9, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp8);
	strmove((USTR) for26_lim, (USTR) tmp9);
	if (strchr((char *) for26_incr,'.')) { 
		for26D=atof(for26_incr);
		for26F=for26D<0.0 ? 1 : 0;
		for26T=1;
		}
	else { 
		for26=atol(for26_incr); 
		for26F=for26<0 ? 1 : 0;
		for26T=0;
		} /* increment */

	for ( sym_(0, (USTR) "k", (USTR) for26_init, svPtr); // init loop variable

	for26F ? /* loop increments or decrements? */
	numcomp((USTR) sym_(11, (USTR) "k", _dummy, svPtr),
	(USTR) for26_lim) >= 0 /* GE limit value? */
	:
	numcomp((USTR) sym_(11, (USTR) "k", _dummy,svPtr),
	(USTR) for26_lim) <= 0; /* LE limit value */

	for26T ? /* increment */
	add3( sym_(11, (USTR) "k", _dummy, svPtr), for26D, (char *) _dummy),
	sym_(0,(USTR) "k",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "k", _dummy, svPtr), for26, (char *) _dummy),
	sym_(0,(USTR) "k", _dummy,svPtr))

	if (setjmp(for26J)==0) goto For26; // else continue

	goto For26Exit; // bypass block 

For26: // for loop entry point

	do { 
	svPtr->LineNumber=78; 
	if (sym_(SYMGET, (USTR) "k", (USTR) tmp11, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "k");
	sub((char *) tmp11,(char *) "1",(char *) tmp12);
{ // local array setup
	int i;
	strmove((USTR) tmp13, (USTR) "c");
	i=strlen((const char *) tmp13);
	tmp13[i]=206;
	tmp13[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp10, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp13,(char *) tmp10);
	i=strlen((const char *) tmp13);
	tmp13[i]=208;
	tmp13[i+1]=0;
	strcat((char *) tmp13,(char *) tmp12);
	i=strlen((const char *) tmp13);
	tmp13[i]=207;
	tmp13[i+1]=0;
	}
{ // local array setup
	int i;
	strmove((USTR) tmp17, (USTR) "c");
	i=strlen((const char *) tmp17);
	tmp17[i]=206;
	tmp17[i+1]=0;
	if (sym_(SYMGET, (USTR) "k", (USTR) tmp15, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "k");
	strcat((char *) tmp17,(char *) tmp15);
	i=strlen((const char *) tmp17);
	tmp17[i]=208;
	tmp17[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp16, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp17,(char *) tmp16);
	i=strlen((const char *) tmp17);
	tmp17[i]=207;
	tmp17[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp13, (USTR) tmp14, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp13);
	if (sym_(SYMGET, (USTR) tmp17, (USTR) tmp18, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp17);
	add((char *) tmp14, (char *) tmp18, (char *) tmp19); 
	if (sym_(SYMGET, (USTR) "x", (USTR) tmp20, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "x");
	if (numcomp((USTR) tmp19, (USTR) tmp20) < 0) strmove((USTR) tmp21, (USTR) "1");
	else strmove((USTR) tmp21, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp21, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	if (sym_(SYMGET, (USTR) "k", (USTR) tmp24, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "k");
	sub((char *) tmp24,(char *) "1",(char *) tmp25);
{ // local array setup
	int i;
	strmove((USTR) tmp26, (USTR) "c");
	i=strlen((const char *) tmp26);
	tmp26[i]=206;
	tmp26[i+1]=0;
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp23, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	strcat((char *) tmp26,(char *) tmp23);
	i=strlen((const char *) tmp26);
	tmp26[i]=208;
	tmp26[i+1]=0;
	strcat((char *) tmp26,(char *) tmp25);
	i=strlen((const char *) tmp26);
	tmp26[i]=207;
	tmp26[i+1]=0;
	}
{ // local array setup
	int i;
	strmove((USTR) tmp30, (USTR) "c");
	i=strlen((const char *) tmp30);
	tmp30[i]=206;
	tmp30[i+1]=0;
	if (sym_(SYMGET, (USTR) "k", (USTR) tmp28, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "k");
	strcat((char *) tmp30,(char *) tmp28);
	i=strlen((const char *) tmp30);
	tmp30[i]=208;
	tmp30[i+1]=0;
	if (sym_(SYMGET, (USTR) "j", (USTR) tmp29, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "j");
	strcat((char *) tmp30,(char *) tmp29);
	i=strlen((const char *) tmp30);
	tmp30[i]=207;
	tmp30[i+1]=0;
	}
	if (sym_(SYMGET, (USTR) tmp26, (USTR) tmp27, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp26);
	if (sym_(SYMGET, (USTR) tmp30, (USTR) tmp31, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) tmp30);
	add((char *) tmp27, (char *) tmp31, (char *) tmp32); 
	sym_(0, (USTR) "x", (USTR) tmp32, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "k", (USTR) tmp34, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "k");
	sym_(0, (USTR) "y", (USTR) tmp34, svPtr); // Store result 
	} while (0); longjmp(for26J,99); // FOR loop 2 close 
	} while (0); longjmp(for26J,99); // FOR loop 1 close 

For26Exit: ; // exit for loop 

//================================================================================= 
svPtr->LineNumber=79; //  quit 
//================================================================================= 
	if (svPtr->Rargsx) { // call-by-reference? 
		int i; 
		unsigned char *tmp = new unsigned char[STR_MAX]; 
		for (i = 0; i < svPtr->Rargsx; i++) { 
		sym_(1, (USTR) svPtr->RefParm[i], (USTR) tmp,svPtr); 
		svPtr->_Sym--; 
		sym_(0, (USTR) svPtr->Rargs[i], (USTR) tmp, svPtr); 
		svPtr->_Sym++; 
		} 
		} 
	strmove((USTR) _ReturnVal, (USTR) ""); 
	if (_doStackN[_doStx]) {  _doStackN[_doStx] = 0; } // Q1001 
	_SymFree(1,svPtr); 
	if (_doStx > 0) { longjmp(_doStack[_doStx],99); } 
	else ErrorMessage("Too Many Quits", svPtr->LineNumber); 

//=================================================================================
_epilogue: tmp0[0]=0; tmp1[0]=0;  /*  Function Epilogue */
	Mltoa(getpid(),atmp);
	if (svPtr->LockDone) cleanLocks((char *) atmp);
	Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */

} // end of try block 

catch(...) { 
     if (GlobalExceptionCode == INPUT_ERROR) cout << "Input Error" << endl;
     else if (GlobalExceptionCode == INPUT_LENGTH) cout << "Input Length Error" << endl;
     else if (GlobalExceptionCode == SYMTAB_ERROR) cout << "Symbol Table Error" << endl;
     else if (GlobalExceptionCode == GLOBAL_NOT_FOUND) cout << "Global Not Found Error" << endl;
     else if (GlobalExceptionCode == INTERPRETER_ERROR) cout << "Interprerer Error" << endl;
     else if (GlobalExceptionCode == INVALID_CONVERSION) cout << "Invalid Conversion Error" << endl;
     else if (GlobalExceptionCode == DATA_RANGE_ERROR) cout << "Data Range Error" << endl;
     else if (GlobalExceptionCode == NUMERIC_RANGE) cout << "Numeric Range Error" << endl;
     else if (GlobalExceptionCode == UNSPECIFIED) cout << "Unspecified Error" << endl;
	cout << "Uncaught error in or near line " 
	<< svPtr->LineNumber << endl;
	Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */
	} 

return EXIT_SUCCESS; }  /* Terminate */
//=================================================================================


int _label_lookup(char *label) {

static struct lab {
	const char *text;
	int offset;
	}
	L[] = {
		"xx", 78,
		"z", 73,
		"y", 59
	};

int lx=-1,i,Lx=3;

	for (i=0; i<Lx; i++) {
		if (strcmp((const char *) L[i].text,(const char *) label)==0) {
			lx=L[i].offset;
			break;
			}
		}
	return lx;
 }
char * _text_function(int disp) { return NULL; }

