// ==============================================================
//#+ This module generated by Mumps Compiler
//#+ Sun Jun 23 21:52:31 2024
//#+ Portions of this code are part of the Mumps Compiler
//#+
//#+ Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005,
//#+ 2010, 2017, 2020, 2022, 2024 by Kevin C. O'Kane
//#+
//#+ Kevin C. O'Kane, Ph.D.
//#+ Professor Emeritus
//#+ Computer Science Department
//#+ University of Northern Iowa
//#+ Cedar Falls, IA 50614-0507
//#+ kc.okane@gmail.com
//#+ okane@uni.edu
//#+ https://threadsafebooks.com
//#+ https://www.cs.uni.edu/~okane
//#+ -----------------------------------
//#+
//#+ Consult individual modules for copyright details
//#+ The runtime libraries are covered by the following license:
//#+
//#+ This library is free software; you can redistribute it and/or
//#+ modify it under the terms of the GNU Lesser General Public
//#+ License as published by the Free Software Foundation; either
//#+ version 2.1 of the License, or (at your option) any later version.
//#+
//#+ This library is distributed in the hope that it will be useful,
//#+ but WITHOUT ANY WARRANTY; without even the implied warranty of
//#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//#+ Lesser General Public License for more details.
//#+
//#+ You should have received a copy of the GNU Lesser General Public
//#+ License along with this library; if not, write to the Free Software
//#+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#+
//#+ This code is unverified - use at your own risk
//#+==============================================================

#undef _MDH_
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <mumpsc/inline.h>
#include <mumpsc/defines.h>
#include <mumpsc/strmax.h>
#include <mumpsc/libmpscpp.h>
#include <mumpsc/sym.h>
#include <mumpsc/builtin.h>
#include <mumpsc/compiler.h>
#define FORPARM STR_MAX  /* Size of For loop parameter */
#define CSTR (char *)
#define UNS unsigned char *
#define uns unsigned char *
#define CCHR const char *
#include <mumpsc/keyfix.h>
#include <mumpsc/globalOrder.h>
#include <mumpsc/stateVector.h>
int (*__label_lookup)(char *);
const char * (*__text_function)(int);
void fcn(MSV *);
void zfcn(unsigned char *, unsigned char *, struct MSV *); /* z functions */
char * sym_(int, unsigned char *, unsigned char *, struct MSV *); /* symbol table */
char * makeLock(char *, char *, char *, char, char *); /* global array lock service */
char * cleanLocks(char *); /* global array lock service */
char * releaseLock(char *, char *, char *); /* global array lock service */
char * eraseLocks(char *); /* global array lock service */
void add(const char *a,const char *b,char *c); /* math function */
void sub(const char *a,const char *b,char *c); /* math function */
void mult(const char *a,const char *b,char *c); /* math function */
void divx(const char *a,const char *b,char *c); /* math function */
void divi(const char *a,const char *b,char *c); /* math function */
void _fnumber(unsigned char *,unsigned char *,
              unsigned char *,unsigned char *, MSV *); /* math function */
int DBSem = 0; /* deadlock prevention */

static inline int floatstring(const char * p) {
    int f=0;
    for (; *p!=0; p++) {
        if (    isdigit(*p) ||
                *p == '-' ||
                *p == '+' ) continue;
        if (    *p=='.' ||
                tolower(*p)=='e' ) {
            f=1;
            continue;
            }
        return 0;
        }
    return f;
    }

inline int numcomp2(unsigned char *aa) {
    if (floatstring((char *) aa)) return (atof( (char *) aa) != 0.0);
    return atoi((char *) aa);
    }

inline char * strxcat(char * a, char *b) {
    while (*a) a++;
    while( (*(a) = *(b)) ) {
        a++;
        b++;
        }
    return a;
    }

inline char * strcatz(char * out, char *in) {
    while (*out) out++;
    while (*(out) = *(in)) {
        out++;
        in++;
        }
    *(out++) = '';
    *out = 0;
    return (char *) out;
    }

void SyncClock() {
    DBSem = 1;
    }

unsigned int set_alarm (unsigned int seconds) {
    struct itimerval old, xnew;
    xnew.it_interval.tv_usec = 0;
    xnew.it_interval.tv_sec = 0 ; // interval between alarms
    xnew.it_value.tv_usec = 0;
    xnew.it_value.tv_sec = (long int) 0;
    if (setitimer (ITIMER_REAL, &xnew, &old) < 0)
        return 0;
    else
        return old.it_value.tv_sec;
    }

#include <mumpsc/global.h>  /* Global array definitions */
/* Interface to Mglobal(): */
/* g = command */
/* key = key sought or stored */
/* bd = value returned or stored */
/* svPtr = address of state vector */
#ifndef SUB
#include <mumpsc/fcns.h>  /* System support functions */
#include <mumpsc/sysfunc.h>  /* Many common global variables */
#endif

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// +

// +     Mumps Bioinformatics Software Library

// +     Copyright (C) 2003, 2004, 2022 by Kevin C. O'Kane

// +

// +     Kevin C. O'Kane

// +     okane@cs.uni.edu

// +

// + This program is free software; you can redistribute it and/or modify

// + it under the terms of the GNU General Public License as published by

// + the Free Software Foundation; either version 2 of the License, or

// + (at your option) any later version.

// +

// + This program is distributed in the hope that it will be useful,

// + but WITHOUT ANY WARRANTY; without even the implied warranty of

// + MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

// + GNU General Public License for more details.

// +

// + You should have received a copy of the GNU General Public License

// + along with this program; if not, write to the Free Software

// + Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

// +

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//=================================================================================
//  zmain
//=================================================================================

int main(int argc, char *argv[]) {

//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#+ Intermediate temporary variables used during execution of string expressions
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    char * catx; // intermediate concat ptr
    char *_ftmp = new char[STR_MAX]; /* intermediate temp */
    /*** Temporary variables */
    char for1_incr[FORPARM], for1_lim[FORPARM], for1_init[FORPARM];
    int for1F;
    int for1T;
    char for2_incr[FORPARM], for2_lim[FORPARM], for2_init[FORPARM];
    int for2F;
    int for2T;
    char for3_incr[FORPARM], for3_lim[FORPARM], for3_init[FORPARM];
    int for3F;
    int for3T;
    jmp_buf for0J;
    jmp_buf for1J;
    jmp_buf for2J;
    jmp_buf for3J;
    jmp_buf for4J;
    jmp_buf Efor0J;
    int tpx0;
    jmp_buf Efor1J;
    int tpx1;
    jmp_buf Efor2J;
    int tpx2;
    jmp_buf Efor3J;
    int tpx3;
    unsigned char *tmp0 = new unsigned char[STR_MAX];
    unsigned char *tmp1 = new unsigned char[STR_MAX];
    unsigned char *tmp2 = new unsigned char[STR_MAX];
    unsigned char *tmp3 = new unsigned char[STR_MAX];
    unsigned char *tmp4 = new unsigned char[STR_MAX];
    unsigned char *_dummy = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *atmp =new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *xgtmp = new unsigned char [STR_MAX]; /* temporary variable */
    unsigned char *gtmpL = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *tmp = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *gtmp = new unsigned char [2*STR_MAX]; /* temporary variable */
    int _label_lookup(char *); /* resolution of labels */
    const char * _text_function(int);
    static unsigned char _ReturnVal[STR_MAX]; /* function returns */
    int _ArgCount=0; /* Nbr of args to extrinsic */
    long _i,_jj,_j,_k,_new;
    int _SymPush=0,f=0;
    int g=0;
    jmp_buf _doStack[128]; /* <do> return stack mechanism */
    short   _doStackN[128]= {0}; /* <do> return stack mechanism */
    static int     _doStx=0; /* <do> return stack mechanism */
    char _Refs[10][32];
    int _Refsx=0;

    if (svPtr == NULL) svPtr = AllocSV();

    _SymPush=0; // zap pushed tables

    svPtr->in_file[5]=stdin; // console default/
    svPtr->out_file[5]=stdout; // console default

    strcpy(svPtr->UDAT,"data.dat");
    strcpy(svPtr->UKEY,"key.dat");

    if ( 0) { // no alarm if slice is zero
        signal(SIGALRM, SyncClock);
        set_alarm(1);
        }

    __label_lookup = _label_lookup;
    __text_function = _text_function;

    $SymPut("%",argv[0]);

    if (argc > 0) {
        for (int i = 0; i < argc; i++) {
            char t[STR_MAX];
            sprintf(t,"%%%d", i);
            $SymPut(t, argv[i]);
            }
        }

    try {

//=================================================================================
        svPtr->LineNumber=27; //  set D=0
//=================================================================================

//--------------
//       Set
//--------------

        sym_(SYMSTORE, (UNS) "D", (UNS) "0", svPtr); // Store result s274

//  open 1:"titles.list,new"

//=================================================================================
        svPtr->LineNumber=29; //  for  do
//=================================================================================

//--------------
//       For
//--------------

        while(1) {  /* Argumentless FOR */

//--------------
//       Do
//--------------

            tpx0 = svPtr->tpx;
            if ( (_i = setjmp(Efor0J)) == 0) goto Do_Block_Entry0; //else continue
            else if (_i == 100) goto Do_Block_Bypass0; // IF_flg m1402
            }

//  . if D>10000 break
        goto Do_Block_Bypass0; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry0:; // Enter Do Block
//-------------------------------------

        do { /* dotted indent entry */

//=================================================================================
            svPtr->LineNumber=31; //  . read line
//=================================================================================

//--------------
//       Read
//--------------

            if (svPtr->in_file[svPtr->io] == NULL)
                ErrorMessage("Read from input file", svPtr->LineNumber);
            svPtr->tpx = getstr1(svPtr->in_file[svPtr->io], &gtmp); // Read string into gtmp
            if (svPtr->tpx >= 0) svPtr->tpx = 1;
            else svPtr->tpx = 0; // Set $Test
            sym_(SYMSTORE, (UNS) "line", (UNS) gtmp, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=32; //  . if '$t break
//=================================================================================

//--------------
//       If
//--------------

            if (svPtr->tpx) tmp0[0]='1'; /* $test */
            else tmp0[0]='0';
            tmp0[1]='\0';
            if (numcomp1( (UNS) tmp0, 0) == 0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                svPtr->tpx=tpx0; // break code: restore $test
                longjmp(Efor0J,100);
                }

//=================================================================================
            svPtr->LineNumber=33; //  . set line=$zblanks(line)
//=================================================================================

//--------------
//       Set
//--------------

            strmove( (UNS) &gtmp[1], (UNS) "");
            catx = strxcat((char *) &gtmp[1],"$zblanks\xce");
            if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
            strxcat((char *) catx,(char *) tmp1);
            strxcat((char *) catx,"\xcf");
            zfcn(gtmp,tmp2,svPtr);
            sym_(SYMSTORE, (UNS) "line", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=34; //  . set lab=$p(line," ",1)
//=================================================================================

//--------------
//       Set
//--------------

            if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
            _piece((UNS) tmp2,
                   (UNS) tmp1,(UNS) " ",(UNS) "1", (UNS) "-1",
                   0, (UNS) "", svPtr); // p1136
            sym_(SYMSTORE, (UNS) "lab", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
            svPtr->LineNumber=35; //  . if lab="ACCESSION" set acc=$p(line," ",2) quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "lab", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "lab"); // not found
            if (strcmp((const char *) tmp0,(const char *) "ACCESSION")==0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp3, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _piece((UNS) tmp4,
                       (UNS) tmp3,(UNS) " ",(UNS) "2", (UNS) "-1",
                       0, (UNS) "", svPtr); // p1136
                sym_(SYMSTORE, (UNS) "acc", (UNS) tmp4, svPtr); // Store result s274

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=36; //  . if lab="DEFINITION" set def=$p(line," ",2,99) quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "lab", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "lab"); // not found
            if (strcmp((const char *) tmp0,(const char *) "DEFINITION")==0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp3, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _piece((UNS) tmp4,
                       (UNS) tmp3,(UNS) " ",(UNS) "2",(UNS) "99",
                       0, (UNS) "", svPtr); // p1136
                sym_(SYMSTORE, (UNS) "def", (UNS) tmp4, svPtr); // Store result s274

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=37; //  . if lab="VERSION" set ver=$p(line," ",2) quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "lab", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "lab"); // not found
            if (strcmp((const char *) tmp0,(const char *) "VERSION")==0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp3, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _piece((UNS) tmp4,
                       (UNS) tmp3,(UNS) " ",(UNS) "2", (UNS) "-1",
                       0, (UNS) "", svPtr); // p1136
                sym_(SYMSTORE, (UNS) "ver", (UNS) tmp4, svPtr); // Store result s274

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=38; //  . if lab="ORIGIN" do
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "lab", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "lab"); // not found
            if (strcmp((const char *) tmp0,(const char *) "ORIGIN")==0)
                strmove( (UNS) tmp1, (UNS) "1");
            else strmove( (UNS) tmp1, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp1 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                tpx1 = svPtr->tpx;
                if ( (_i = setjmp(Efor1J)) == 0) goto Do_Block_Entry1; //else continue
                else if (_i == 100) goto Do_Block_Bypass1; // IF_flg m1402
                }
            goto Do_Block_Bypass1; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry1:; // Enter Do Block
//-------------------------------------

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=39; //  .. write ">gi|",ver,"| ",acc," ",def,! set off=$ztell use 5
//=================================================================================

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 ">gi|");
                if (sym_(SYMGET, (UNS) "ver", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "ver"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp0);
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 "| ");
                if (sym_(SYMGET, (UNS) "acc", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "acc"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp1);
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 " ");
                if (sym_(SYMGET, (UNS) "def", (UNS) tmp2, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "def"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp2);
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;

//--------------
//       Set
//--------------

                strcpy((char *) &gtmp[1],(const char *) "$ztell");
                zfcn(gtmp,tmp4,svPtr);
                sym_(SYMSTORE, (UNS) "off", (UNS) tmp4, svPtr); // Store result s274

//--------------
//       Use
//--------------

                svPtr->io=atoi( CSTR "5");

//  .. write off," ",D," " set D=D+1

//=================================================================================
                svPtr->LineNumber=41; //  .. set max=0
//=================================================================================

//--------------
//       Set
//--------------

                sym_(SYMSTORE, (UNS) "max", (UNS) "0", svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=42; //  .. set k=0
//=================================================================================

//--------------
//       Set
//--------------

                sym_(SYMSTORE, (UNS) "k", (UNS) "0", svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=43; //  .. for i=1:1 do
//=================================================================================

//--------------
//       For
//--------------

                strcpy(for3_lim, "");
                strmove((UNS) for3_init, (UNS) "1"); // init value m2534
                strmove( (UNS) for3_incr, (UNS) "1"); // inc/dec m2575

                if (strchr((char *) for3_incr, '.')) // inc/dec is float
                    for3F = atof(for3_incr) < 0.0 ? 1 : 0; // incr or decr?
                else // inc/dec is integer
                    for3F = atol(for3_incr) < 0 ? 1 : 0; // incr or decr?

                for ( sym_(SYMSTORE, (UNS) "i", (UNS) for3_init, svPtr); // init 2618

                        1;  // limit expression - no limit

                        add( sym_(11, (UNS) "i", _dummy, svPtr), // inc/dec loop var
                             for3_incr, (char *) _dummy),
                        sym_(SYMSTORE, (UNS) "i", (UNS) _dummy, svPtr) ) // store rslt

                    if ((_i = setjmp(for3J)) == 0) goto For3; // else continue

                    else if (_i == 100) goto For3Exit; // f273

                goto For3Exit; // bypass block

For3: // for loop body entry point B

                do { // for loop body
                    svPtr->LineNumber = 43;

//--------------
//       Do
//--------------

                    tpx2 = svPtr->tpx;
                    if ( (_i = setjmp(Efor2J)) == 0) goto Do_Block_Entry2; //else continue
                    else if (_i == 100) goto Do_Block_Bypass2; // IF_flg m1402
                    }
                while (0);
                longjmp(for3J, _i); // FOR loop 1 close

For3Exit: ; // exit for loop

                goto Do_Block_Bypass2; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry2:; // Enter Do Block
//-------------------------------------

                do { /* dotted indent entry */

//=================================================================================
                    svPtr->LineNumber=44; //  ... read line
//=================================================================================

//--------------
//       Read
//--------------

                    if (svPtr->in_file[svPtr->io] == NULL)
                        ErrorMessage("Read from input file", svPtr->LineNumber);
                    svPtr->tpx = getstr1(svPtr->in_file[svPtr->io], &gtmp); // Read string into gtmp
                    if (svPtr->tpx >= 0) svPtr->tpx = 1;
                    else svPtr->tpx = 0; // Set $Test
                    sym_(SYMSTORE, (UNS) "line", (UNS) gtmp, svPtr); // Store result s274

//=================================================================================
                    svPtr->LineNumber=45; //  ... if '$test break
//=================================================================================

//--------------
//       If
//--------------

                    if (svPtr->tpx) tmp0[0]='1'; /* $test */
                    else tmp0[0]='0';
                    tmp0[1]='\0';
                    if (numcomp1( (UNS) tmp0, 0) == 0)
                        strmove( (UNS) tmp1, (UNS) "1");
                    else strmove( (UNS) tmp1, (UNS) "0");
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp1 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                        svPtr->tpx=tpx2; // break code: restore $test
                        longjmp(Efor2J,100);
                        }

//=================================================================================
                    svPtr->LineNumber=46; //  ... if line="//" break
//=================================================================================

//--------------
//       If
//--------------

                    if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                    if (strcmp((const char *) tmp0,(const char *) "//")==0)
                        strmove( (UNS) tmp1, (UNS) "1");
                    else strmove( (UNS) tmp1, (UNS) "0");
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp1 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                        svPtr->tpx=tpx2; // break code: restore $test
                        longjmp(Efor2J,100);
                        }

//=================================================================================
                    svPtr->LineNumber=47; //  ... set line=$e(line,11,100)
//=================================================================================

//--------------
//       Set
//--------------

                    if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                    _extract( (UNS) tmp2,
                              (UNS) tmp1, (UNS) "11", (UNS) "100"); // p2493
                    sym_(SYMSTORE, (UNS) "line", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
                    svPtr->LineNumber=48; //  ... write $translate(line," "),!
//=================================================================================

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    strmove( (UNS) &gtmp[1], (UNS) "");
                    catx = strxcat((char *) &gtmp[1],"$translate\xce");
                    if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                    strxcat((char *) catx,(char *) tmp0);
                    strxcat((char *) catx,"\xd0");
                    strxcat((char *) catx,(char *) " ");
                    strxcat((char *) catx,"\xcf");
                    strmove((UNS) &svPtr->v1d[1], (UNS) &gtmp[1]);
                    fcn(svPtr);
                    strmove((UNS) tmp1, (UNS) &svPtr->bd[1]);
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     tmp1);
                    fprintf(svPtr->out_file[svPtr->io], "\n");
                    svPtr->hor[svPtr->io]=0;
                    svPtr->ver[svPtr->io]++;

//  close 1
                    }
                while (0);     // dotted un-indent 2
                longjmp(Efor2J,99);    // return

Do_Block_Bypass2: ; //A541
                }
            while (0);     // dotted un-indent 1
            longjmp(Efor1J,99);    // return

Do_Block_Bypass1: ; //A541
            }
        while (0);     // dotted un-indent 0
        longjmp(Efor0J,99);    // return

Do_Block_Bypass0: ; //A541

//=================================================================================
_epilogue:
        tmp0[0]=0;
        tmp1[0]=0;  /*  Function Epilogue */
        Mltoa(getpid(),atmp);
        if (svPtr->LockDone) cleanLocks((char *) atmp);
        Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */

        } // end of try block

    catch(...) {
        if (GlobalExceptionCode == INPUT_ERROR) cout << "Input Error" << endl;
        else if (GlobalExceptionCode == INPUT_LENGTH) cout << "Input Length Error" << endl;
        else if (GlobalExceptionCode == SYMTAB_ERROR) cout << "Symbol Table Error" << endl;
        else if (GlobalExceptionCode == GLOBAL_NOT_FOUND) cout << "Global Not Found Error" << endl;
        else if (GlobalExceptionCode == INTERPRETER_ERROR) cout << "Interprerer Error" << endl;
        else if (GlobalExceptionCode == INVALID_CONVERSION) cout << "Invalid Conversion Error" << endl;
        else if (GlobalExceptionCode == DATA_RANGE_ERROR) cout << "Data Range Error" << endl;
        else if (GlobalExceptionCode == NUMERIC_RANGE) cout << "Numeric Range Error" << endl;
        else if (GlobalExceptionCode == UNSPECIFIED) cout << "Unspecified Error" << endl;
        cout << "Uncaught error in or near line "
             << svPtr->LineNumber << endl;
        Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */
        }

    return EXIT_SUCCESS;
    }  /* Terminate */
//=================================================================================


int _label_lookup(char *label) {
    return -1;
    }
const char * _text_function(int disp) {
    return NULL;
    }

