// ==============================================================
//#+ This module generated by Mumps Compiler
//#+ Sun Jun 23 21:52:31 2024
//#+ Portions of this code are part of the Mumps Compiler
//#+
//#+ Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005,
//#+ 2010, 2017, 2020, 2022, 2024 by Kevin C. O'Kane
//#+
//#+ Kevin C. O'Kane, Ph.D.
//#+ Professor Emeritus
//#+ Computer Science Department
//#+ University of Northern Iowa
//#+ Cedar Falls, IA 50614-0507
//#+ kc.okane@gmail.com
//#+ okane@uni.edu
//#+ https://threadsafebooks.com
//#+ https://www.cs.uni.edu/~okane
//#+ -----------------------------------
//#+
//#+ Consult individual modules for copyright details
//#+ The runtime libraries are covered by the following license:
//#+
//#+ This library is free software; you can redistribute it and/or
//#+ modify it under the terms of the GNU Lesser General Public
//#+ License as published by the Free Software Foundation; either
//#+ version 2.1 of the License, or (at your option) any later version.
//#+
//#+ This library is distributed in the hope that it will be useful,
//#+ but WITHOUT ANY WARRANTY; without even the implied warranty of
//#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//#+ Lesser General Public License for more details.
//#+
//#+ You should have received a copy of the GNU Lesser General Public
//#+ License along with this library; if not, write to the Free Software
//#+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#+
//#+ This code is unverified - use at your own risk
//#+==============================================================

#undef _MDH_
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <mumpsc/inline.h>
#include <mumpsc/defines.h>
#include <mumpsc/strmax.h>
#include <mumpsc/libmpscpp.h>
#include <mumpsc/sym.h>
#include <mumpsc/builtin.h>
#include <mumpsc/compiler.h>
#define FORPARM STR_MAX  /* Size of For loop parameter */
#define CSTR (char *)
#define UNS unsigned char *
#define uns unsigned char *
#define CCHR const char *
#include <mumpsc/keyfix.h>
#include <mumpsc/globalOrder.h>
#include <mumpsc/stateVector.h>
int (*__label_lookup)(char *);
const char * (*__text_function)(int);
void fcn(MSV *);
void zfcn(unsigned char *, unsigned char *, struct MSV *); /* z functions */
char * sym_(int, unsigned char *, unsigned char *, struct MSV *); /* symbol table */
char * makeLock(char *, char *, char *, char, char *); /* global array lock service */
char * cleanLocks(char *); /* global array lock service */
char * releaseLock(char *, char *, char *); /* global array lock service */
char * eraseLocks(char *); /* global array lock service */
void add(const char *a,const char *b,char *c); /* math function */
void sub(const char *a,const char *b,char *c); /* math function */
void mult(const char *a,const char *b,char *c); /* math function */
void divx(const char *a,const char *b,char *c); /* math function */
void divi(const char *a,const char *b,char *c); /* math function */
void _fnumber(unsigned char *,unsigned char *,
              unsigned char *,unsigned char *, MSV *); /* math function */
int DBSem = 0; /* deadlock prevention */

static inline int floatstring(const char * p) {
    int f=0;
    for (; *p!=0; p++) {
        if (    isdigit(*p) ||
                *p == '-' ||
                *p == '+' ) continue;
        if (    *p=='.' ||
                tolower(*p)=='e' ) {
            f=1;
            continue;
            }
        return 0;
        }
    return f;
    }

inline int numcomp2(unsigned char *aa) {
    if (floatstring((char *) aa)) return (atof( (char *) aa) != 0.0);
    return atoi((char *) aa);
    }

inline char * strxcat(char * a, char *b) {
    while (*a) a++;
    while( (*(a) = *(b)) ) {
        a++;
        b++;
        }
    return a;
    }

inline char * strcatz(char * out, char *in) {
    while (*out) out++;
    while (*(out) = *(in)) {
        out++;
        in++;
        }
    *(out++) = '';
    *out = 0;
    return (char *) out;
    }

void SyncClock() {
    DBSem = 1;
    }

unsigned int set_alarm (unsigned int seconds) {
    struct itimerval old, xnew;
    xnew.it_interval.tv_usec = 0;
    xnew.it_interval.tv_sec = 0 ; // interval between alarms
    xnew.it_value.tv_usec = 0;
    xnew.it_value.tv_sec = (long int) 0;
    if (setitimer (ITIMER_REAL, &xnew, &old) < 0)
        return 0;
    else
        return old.it_value.tv_sec;
    }

#include <mumpsc/global.h>  /* Global array definitions */
/* Interface to Mglobal(): */
/* g = command */
/* key = key sought or stored */
/* bd = value returned or stored */
/* svPtr = address of state vector */
#ifndef SUB
#include <mumpsc/fcns.h>  /* System support functions */
#include <mumpsc/sysfunc.h>  /* Many common global variables */
#endif

// !/usr/bin/mumps

//  Copyright 2014, 2022 Kevin C. O'Kane

//  reformat.mps March 29, 2022

//=================================================================================
//  zmain
//=================================================================================

int main(int argc, char *argv[]) {

//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#+ Intermediate temporary variables used during execution of string expressions
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    char * catx; // intermediate concat ptr
    char *_ftmp = new char[STR_MAX]; /* intermediate temp */
    /*** Temporary variables */
    char for1_incr[FORPARM], for1_lim[FORPARM], for1_init[FORPARM];
    int for1F;
    int for1T;
    char for2_incr[FORPARM], for2_lim[FORPARM], for2_init[FORPARM];
    int for2F;
    int for2T;
    char for3_incr[FORPARM], for3_lim[FORPARM], for3_init[FORPARM];
    int for3F;
    int for3T;
    char for4_incr[FORPARM], for4_lim[FORPARM], for4_init[FORPARM];
    int for4F;
    int for4T;
    char for5_incr[FORPARM], for5_lim[FORPARM], for5_init[FORPARM];
    int for5F;
    int for5T;
    char for6_incr[FORPARM], for6_lim[FORPARM], for6_init[FORPARM];
    int for6F;
    int for6T;
    jmp_buf for0J;
    jmp_buf for1J;
    jmp_buf for2J;
    jmp_buf for3J;
    jmp_buf for4J;
    jmp_buf for5J;
    jmp_buf for6J;
    jmp_buf for7J;
    jmp_buf Efor0J;
    int tpx0;
    jmp_buf Efor1J;
    int tpx1;
    jmp_buf Efor2J;
    int tpx2;
    jmp_buf Efor3J;
    int tpx3;
    jmp_buf Efor4J;
    int tpx4;
    jmp_buf Efor5J;
    int tpx5;
    unsigned char *tmp0 = new unsigned char[STR_MAX];
    unsigned char *tmp1 = new unsigned char[STR_MAX];
    unsigned char *tmp2 = new unsigned char[STR_MAX];
    unsigned char *tmp3 = new unsigned char[STR_MAX];
    unsigned char *tmp4 = new unsigned char[STR_MAX];
    unsigned char *tmp5 = new unsigned char[STR_MAX];
    unsigned char *tmp6 = new unsigned char[STR_MAX];
    unsigned char *_dummy = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *atmp =new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *xgtmp = new unsigned char [STR_MAX]; /* temporary variable */
    unsigned char *gtmpL = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *tmp = new unsigned char[STR_MAX]; /* temporary variable */
    unsigned char *gtmp = new unsigned char [2*STR_MAX]; /* temporary variable */
    int _label_lookup(char *); /* resolution of labels */
    const char * _text_function(int);
    static unsigned char _ReturnVal[STR_MAX]; /* function returns */
    int _ArgCount=0; /* Nbr of args to extrinsic */
    long _i,_jj,_j,_k,_new;
    int _SymPush=0,f=0;
    int g=0;
    jmp_buf _doStack[128]; /* <do> return stack mechanism */
    short   _doStackN[128]= {0}; /* <do> return stack mechanism */
    static int     _doStx=0; /* <do> return stack mechanism */
    char _Refs[10][32];
    int _Refsx=0;

    if (svPtr == NULL) svPtr = AllocSV();

    _SymPush=0; // zap pushed tables

    svPtr->in_file[5]=stdin; // console default/
    svPtr->out_file[5]=stdout; // console default

    strcpy(svPtr->UDAT,"data.dat");
    strcpy(svPtr->UKEY,"key.dat");

    if ( 0) { // no alarm if slice is zero
        signal(SIGALRM, SyncClock);
        set_alarm(1);
        }

    __label_lookup = _label_lookup;
    __text_function = _text_function;

    $SymPut("%",argv[0]);

    if (argc > 0) {
        for (int i = 0; i < argc; i++) {
            char t[STR_MAX];
            sprintf(t,"%%%d", i);
            $SymPut(t, argv[i]);
            }
        }

    try {

//=================================================================================
        svPtr->LineNumber=8; //  set M=$zgetenv("max_docs")
//=================================================================================

//--------------
//       Set
//--------------

        strmove( (UNS) &gtmp[1], (UNS) "");
        catx = strxcat((char *) &gtmp[1],"$zgetenv\xce");
        strxcat((char *) catx,(char *) "max_docs");
        strxcat((char *) catx,"\xcf");
        zfcn(gtmp,tmp1,svPtr);
        sym_(SYMSTORE, (UNS) "M", (UNS) tmp1, svPtr); // Store result s274

//=================================================================================
        svPtr->LineNumber=9; //  if M="" set M=1000000
//=================================================================================

//--------------
//       If
//--------------

        if (sym_(SYMGET, (UNS) "M", (UNS) tmp0, svPtr) == NULL) // get value
            VariableNotFound1(svPtr->LineNumber, (UNS) "M"); // not found
        if (strcmp((const char *) tmp0,(const char *) "")==0)
            strmove( (UNS) tmp1, (UNS) "1");
        else strmove( (UNS) tmp1, (UNS) "0");
        svPtr->tpx = 0; //Default $Test indicator
        if (numcomp2((UNS) tmp1 )) { // Test if true
            svPtr->tpx = 1; // $test becomes true

//--------------
//       Set
//--------------

            sym_(SYMSTORE, (UNS) "M", (UNS) "1000000", svPtr); // Store result s274
            }

//=================================================================================
        svPtr->LineNumber=10; //  open 1:"titles.list,new"
//=================================================================================

//--------------
//       Open
//--------------

        _i = atoi( CSTR "1");
        strmove((UNS) tmp0, (UNS) "titles.list,new");
        for(_j=0; tmp0[_j]!=0 && tmp0[_j]!=','; _j++);
        if (tmp0[_j]!=',') ErrorMessage("File open error",svPtr->LineNumber);
        tmp0[_j++]=0;
        strmove((UNS) gtmp, (UNS) tmp0);
        if (strcmp( (CCHR) &tmp0[_j], (CCHR) "old") == 0 ||
                strcmp( (CCHR) &tmp0[_j], (CCHR) "OLD") == 0) _new = 0;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "new") == 0 ||
                 strcmp((CCHR) &tmp0[_j], (CCHR) "NEW") == 0) _new = 1;
        else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "append") == 0 ||
                 strcmp( (CCHR) &tmp0[_j], (const char *) "APPEND") == 0) _new=2;
        else ErrorMessage("File open error",svPtr->LineNumber);
        if (svPtr->out_file[_i] != NULL || svPtr->in_file[_i] != NULL)
            ErrorMessage("File already open", svPtr->LineNumber);
        if (_new==1) { /* output */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "w");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else if (_new == 2) { /* append */
            svPtr->out_file[_i] = fopen((const char *) gtmp, "a");
            if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }
        else { /* input */
            svPtr->in_file[_i] = fopen((const char *) gtmp, "r");
            if(svPtr->in_file[_i] == NULL) svPtr->tpx = 0;
            else svPtr->tpx = 1;
            }

//=================================================================================
        svPtr->LineNumber=11; //  kill ^map
//=================================================================================

//--------------
//       Kill
//--------------

        strmove( (UNS) gtmp, (UNS) "");
        strcat((char *) gtmp,(char *) "^map");
            {
            unsigned char tmp14[STR_MAX], tmp15[STR_MAX];
            keyfix(gtmp);
            _k = strlen((const char *) gtmp);
            strmove((UNS) tmp14, (UNS) gtmp);
            Mglobal(GKILL, gtmp, tmp15, svPtr);
            while(1) {
                _j = Mglobal(XNEXT, gtmp, tmp15, svPtr);
                if (_j && strncmp( (CCHR) tmp14, (CCHR) gtmp,_k) == 0) {
                    Mglobal(GKILL, gtmp, tmp15, svPtr);
                    continue;
                    }
                break;
                }
            }

//=================================================================================
        svPtr->LineNumber=13; //  set D=0
//=================================================================================

//--------------
//       Set
//--------------

        sym_(SYMSTORE, (UNS) "D", (UNS) "0", svPtr); // Store result s274

//=================================================================================
        svPtr->LineNumber=15; //  for  do  if D>M quit
//=================================================================================

//--------------
//       For
//--------------

        while(1) {  /* Argumentless FOR */

//--------------
//       Do
//--------------

            tpx0 = svPtr->tpx;
            if ( (_i = setjmp(Efor0J)) == 0) goto Do_Block_Entry0; //else continue
            else if (_i == 100) goto Do_Block_Bypass0; // IF_flg m1402

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "D", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "D"); // not found
            if (sym_(SYMGET, (UNS) "M", (UNS) tmp1, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "M"); // not found
            if (numcomp((UNS) tmp0, (UNS) tmp1) > 0) strmove((UNS) tmp2, (UNS) "1");
            else strmove((UNS) tmp2, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp2 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Quit
//--------------

                break;
                } // if block 2389
            }
        goto Do_Block_Bypass0; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry0:; // Enter Do Block
//-------------------------------------

        do { /* dotted indent entry */

//=================================================================================
            svPtr->LineNumber=16; //  . set o=$ztell read line if '$test break
//=================================================================================

//--------------
//       Set
//--------------

            strcpy((char *) &gtmp[1],(const char *) "$ztell");
            zfcn(gtmp,tmp1,svPtr);
            sym_(SYMSTORE, (UNS) "o", (UNS) tmp1, svPtr); // Store result s274

//--------------
//       Read
//--------------

            if (svPtr->in_file[svPtr->io] == NULL)
                ErrorMessage("Read from input file", svPtr->LineNumber);
            svPtr->tpx = getstr1(svPtr->in_file[svPtr->io], &gtmp); // Read string into gtmp
            if (svPtr->tpx >= 0) svPtr->tpx = 1;
            else svPtr->tpx = 0; // Set $Test
            sym_(SYMSTORE, (UNS) "line", (UNS) gtmp, svPtr); // Store result s274

//--------------
//       If
//--------------

            if (svPtr->tpx) tmp3[0]='1'; /* $test */
            else tmp3[0]='0';
            tmp3[1]='\0';
            if (numcomp1( (UNS) tmp3, 0) == 0)
                strmove( (UNS) tmp4, (UNS) "1");
            else strmove( (UNS) tmp4, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp4 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                svPtr->tpx=tpx0; // break code: restore $test
                longjmp(Efor0J,100);
                }

//=================================================================================
            svPtr->LineNumber=17; //  . if $extract(line,1,2)="TI" do  quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
            _extract( (UNS) tmp1,
                      (UNS) tmp0, (UNS) "1", (UNS) "2"); // p2493
            if (strcmp((const char *) tmp1,(const char *) "TI")==0)
                strmove( (UNS) tmp2, (UNS) "1");
            else strmove( (UNS) tmp2, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp2 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Do
//--------------

                tpx1 = svPtr->tpx;
                if ( (_i = setjmp(Efor1J)) == 0) goto Do_Block_Entry1; //else continue
                else if (_i == 100) goto Do_Block_Bypass1; // IF_flg m1402

//--------------
//       Quit
//--------------

                break;
                } // if block 2389
            goto Do_Block_Bypass1; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry1:; // Enter Do Block
//-------------------------------------

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=18; //  .. set D=D+1
//=================================================================================

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "D", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "D"); // not found
                add( (char *) tmp1, "1", (char *) tmp2 );
                sym_(SYMSTORE, (UNS) "D", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=19; //  .. use 1 write D," ",$extract(line,7,200),! use 5
//=================================================================================

//--------------
//       Use
//--------------

                svPtr->io=atoi( CSTR "1");

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                if (sym_(SYMGET, (UNS) "D", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "D"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp0);
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 " ");
                if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _extract( (UNS) tmp2,
                          (UNS) tmp1, (UNS) "7", (UNS) "200"); // p2493
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp2);
                fprintf(svPtr->out_file[svPtr->io], "\n");
                svPtr->hor[svPtr->io]=0;
                svPtr->ver[svPtr->io]++;

//--------------
//       Use
//--------------

                svPtr->io=atoi( CSTR "5");

//=================================================================================
                svPtr->LineNumber=20; //  .. write off," ",D
//=================================================================================

//--------------
//       Write
//--------------

                if (svPtr->out_file[svPtr->io]==NULL)
                    ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                if (sym_(SYMGET, (UNS) "off", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "off"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp0);
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 " ");
                if (sym_(SYMGET, (UNS) "D", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "D"); // not found
                svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                 tmp1);

//=================================================================================
                svPtr->LineNumber=21; //  .. set ^map(D)=off
//=================================================================================

//--------------
//       Set
//--------------

                strmove((UNS) tmp1, (UNS) "map\xce"); // M3701
                if (sym_(SYMGET, (UNS) "D", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "D"); // not found
                catx = strxcat((char *) tmp1, (char *) tmp0); // a2926
                strcat((char *) catx, (char *) "\xcf"); //a3956

                    {
                    if (sym_(SYMGET, (UNS) "off", (UNS) tmp2, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "off"); // not found
                    f = Mglobal(STORE, tmp1, tmp2, svPtr);
                    }


//=================================================================================
                svPtr->LineNumber=22; //  .. set line=$zlower($e(line,7,2048))
//=================================================================================

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _extract( (UNS) tmp2,
                          (UNS) tmp1, (UNS) "7", (UNS) "2048"); // p2493
                strmove( (UNS) &gtmp[1], (UNS) "");
                catx = strxcat((char *) &gtmp[1],"$zlower\xce");
                strxcat((char *) catx,(char *) tmp2);
                strxcat((char *) catx,"\xcf");
                zfcn(gtmp,tmp3,svPtr);
                sym_(SYMSTORE, (UNS) "line", (UNS) tmp3, svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=23; //  .. set line=$zblanks(line)
//=================================================================================

//--------------
//       Set
//--------------

                strmove( (UNS) &gtmp[1], (UNS) "");
                catx = strxcat((char *) &gtmp[1],"$zblanks\xce");
                if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                strxcat((char *) catx,(char *) tmp1);
                strxcat((char *) catx,"\xcf");
                zfcn(gtmp,tmp2,svPtr);
                sym_(SYMSTORE, (UNS) "line", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=24; //  .. for i=1:1 do
//=================================================================================

//--------------
//       For
//--------------

                strcpy(for3_lim, "");
                strmove((UNS) for3_init, (UNS) "1"); // init value m2534
                strmove( (UNS) for3_incr, (UNS) "1"); // inc/dec m2575

                if (strchr((char *) for3_incr, '.')) // inc/dec is float
                    for3F = atof(for3_incr) < 0.0 ? 1 : 0; // incr or decr?
                else // inc/dec is integer
                    for3F = atol(for3_incr) < 0 ? 1 : 0; // incr or decr?

                for ( sym_(SYMSTORE, (UNS) "i", (UNS) for3_init, svPtr); // init 2618

                        1;  // limit expression - no limit

                        add( sym_(11, (UNS) "i", _dummy, svPtr), // inc/dec loop var
                             for3_incr, (char *) _dummy),
                        sym_(SYMSTORE, (UNS) "i", (UNS) _dummy, svPtr) ) // store rslt

                    if ((_i = setjmp(for3J)) == 0) goto For3; // else continue

                    else if (_i == 100) goto For3Exit; // f273

                goto For3Exit; // bypass block

For3: // for loop body entry point B

                do { // for loop body
                    svPtr->LineNumber = 24;

//--------------
//       Do
//--------------

                    tpx2 = svPtr->tpx;
                    if ( (_i = setjmp(Efor2J)) == 0) goto Do_Block_Entry2; //else continue
                    else if (_i == 100) goto Do_Block_Bypass2; // IF_flg m1402
                    }
                while (0);
                longjmp(for3J, _i); // FOR loop 1 close

For3Exit: ; // exit for loop

                goto Do_Block_Bypass2; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry2:; // Enter Do Block
//-------------------------------------

                do { /* dotted indent entry */

//=================================================================================
                    svPtr->LineNumber=25; //  ... s w=$p(line," ",i) if $l(w)=0 break
//=================================================================================

//--------------
//       Set
//--------------

                    if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                    if (sym_(SYMGET, (UNS) "i", (UNS) tmp2, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "i"); // not found
                    _piece((UNS) tmp3,
                           (UNS) tmp1,(UNS) " ",(UNS) tmp2, (UNS) "-1",
                           0, (UNS) "", svPtr); // p1136
                    sym_(SYMSTORE, (UNS) "w", (UNS) tmp3, svPtr); // Store result s274

//--------------
//       If
//--------------

                    if (sym_(SYMGET, (UNS) "w", (UNS) tmp4, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                    _length((UNS) tmp5, (UNS) tmp4, (UNS) "");
                    if (strcmp((const char *) tmp5,(const char *) "0")==0)
                        strmove( (UNS) tmp6, (UNS) "1");
                    else strmove( (UNS) tmp6, (UNS) "0");
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp6 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                        svPtr->tpx=tpx2; // break code: restore $test
                        longjmp(Efor2J,100);
                        }

//=================================================================================
                    svPtr->LineNumber=26; //  ... w " ",w
//=================================================================================

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     " ");
                    if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     tmp0);
                    }
                while (0);   /* dotted un-indent 2 */
                longjmp(Efor2J,99); /* return */

Do_Block_Bypass2: ; // D3607
                }
            while (0);   /* dotted un-indent 1 */
            longjmp(Efor1J,99); /* return */

Do_Block_Bypass1: ; // D3607

//=================================================================================
            svPtr->LineNumber=27; //  . if $extract(line,1,2)="MH" quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
            _extract( (UNS) tmp1,
                      (UNS) tmp0, (UNS) "1", (UNS) "2"); // p2493
            if (strcmp((const char *) tmp1,(const char *) "MH")==0)
                strmove( (UNS) tmp2, (UNS) "1");
            else strmove( (UNS) tmp2, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp2 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=28; //  . if $extract(line,1,13)="STAT- MEDLINE" set off=o write:D'=0 ! quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
            _extract( (UNS) tmp1,
                      (UNS) tmp0, (UNS) "1", (UNS) "13"); // p2493
            if (strcmp((const char *) tmp1,(const char *) "STAT- MEDLINE")==0)
                strmove( (UNS) tmp2, (UNS) "1");
            else strmove( (UNS) tmp2, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp2 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "o", (UNS) tmp4, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "o"); // not found
                sym_(SYMSTORE, (UNS) "off", (UNS) tmp4, svPtr); // Store result s274
                if (sym_(SYMGET, (UNS) "D", (UNS) tmp5, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "D"); // not found
                if (strcmp((const char *) tmp5, (const char *) "0") != 0)
                    strmove((UNS) tmp6, (UNS) "1");
                else strmove((UNS) tmp6, (UNS) "0");
                if (atoi( CSTR tmp6)) { // m859 postconditional

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    fprintf(svPtr->out_file[svPtr->io], "\n");
                    svPtr->hor[svPtr->io]=0;
                    svPtr->ver[svPtr->io]++;
                    } /* post conditional 4092*/

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=29; //  . if $extract(line,1,2)'="AB" quit
//=================================================================================

//--------------
//       If
//--------------

            if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
            _extract( (UNS) tmp1,
                      (UNS) tmp0, (UNS) "1", (UNS) "2"); // p2493
            if (strcmp((const char *) tmp1, (const char *) "AB") != 0)
                strmove((UNS) tmp2, (UNS) "1");
            else strmove((UNS) tmp2, (UNS) "0");
            svPtr->tpx = 0; //Default $Test indicator
            if (numcomp2((UNS) tmp2 )) { // Test if true
                svPtr->tpx = 1; // $test becomes true

//--------------
//       Quit
//--------------

                break;
                } // if block 2389

//=================================================================================
            svPtr->LineNumber=30; //  . for  do
//=================================================================================

//--------------
//       For
//--------------

            while(1) {  /* Argumentless FOR */

//--------------
//       Do
//--------------

                tpx3 = svPtr->tpx;
                if ( (_i = setjmp(Efor3J)) == 0) goto Do_Block_Entry3; //else continue
                else if (_i == 100) goto Do_Block_Bypass3; // IF_flg m1402
                }
            goto Do_Block_Bypass3; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry3:; // Enter Do Block
//-------------------------------------

            do { /* dotted indent entry */

//=================================================================================
                svPtr->LineNumber=31; //  .. set line=$zlower($e(line,7,2048))
//=================================================================================

//--------------
//       Set
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _extract( (UNS) tmp2,
                          (UNS) tmp1, (UNS) "7", (UNS) "2048"); // p2493
                strmove( (UNS) &gtmp[1], (UNS) "");
                catx = strxcat((char *) &gtmp[1],"$zlower\xce");
                strxcat((char *) catx,(char *) tmp2);
                strxcat((char *) catx,"\xcf");
                zfcn(gtmp,tmp3,svPtr);
                sym_(SYMSTORE, (UNS) "line", (UNS) tmp3, svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=32; //  .. set line=$zblanks(line)
//=================================================================================

//--------------
//       Set
//--------------

                strmove( (UNS) &gtmp[1], (UNS) "");
                catx = strxcat((char *) &gtmp[1],"$zblanks\xce");
                if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                strxcat((char *) catx,(char *) tmp1);
                strxcat((char *) catx,"\xcf");
                zfcn(gtmp,tmp2,svPtr);
                sym_(SYMSTORE, (UNS) "line", (UNS) tmp2, svPtr); // Store result s274

//=================================================================================
                svPtr->LineNumber=33; //  .. for i=1:1 do
//=================================================================================

//--------------
//       For
//--------------

                strcpy(for6_lim, "");
                strmove((UNS) for6_init, (UNS) "1"); // init value m2534
                strmove( (UNS) for6_incr, (UNS) "1"); // inc/dec m2575

                if (strchr((char *) for6_incr, '.')) // inc/dec is float
                    for6F = atof(for6_incr) < 0.0 ? 1 : 0; // incr or decr?
                else // inc/dec is integer
                    for6F = atol(for6_incr) < 0 ? 1 : 0; // incr or decr?

                for ( sym_(SYMSTORE, (UNS) "i", (UNS) for6_init, svPtr); // init 2618

                        1;  // limit expression - no limit

                        add( sym_(11, (UNS) "i", _dummy, svPtr), // inc/dec loop var
                             for6_incr, (char *) _dummy),
                        sym_(SYMSTORE, (UNS) "i", (UNS) _dummy, svPtr) ) // store rslt

                    if ((_i = setjmp(for6J)) == 0) goto For6; // else continue

                    else if (_i == 100) goto For6Exit; // f273

                goto For6Exit; // bypass block

For6: // for loop body entry point B

                do { // for loop body
                    svPtr->LineNumber = 33;

//--------------
//       Do
//--------------

                    tpx4 = svPtr->tpx;
                    if ( (_i = setjmp(Efor4J)) == 0) goto Do_Block_Entry4; //else continue
                    else if (_i == 100) goto Do_Block_Bypass4; // IF_flg m1402
                    }
                while (0);
                longjmp(for6J, _i); // FOR loop 1 close

For6Exit: ; // exit for loop

                goto Do_Block_Bypass4; // C3551 bypass indented group

//-------------------------------------
Do_Block_Entry4:; // Enter Do Block
//-------------------------------------

                do { /* dotted indent entry */

//=================================================================================
                    svPtr->LineNumber=34; //  ... set w=$p(line," ",i) if $l(w)=0 break
//=================================================================================

//--------------
//       Set
//--------------

                    if (sym_(SYMGET, (UNS) "line", (UNS) tmp1, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                    if (sym_(SYMGET, (UNS) "i", (UNS) tmp2, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "i"); // not found
                    _piece((UNS) tmp3,
                           (UNS) tmp1,(UNS) " ",(UNS) tmp2, (UNS) "-1",
                           0, (UNS) "", svPtr); // p1136
                    sym_(SYMSTORE, (UNS) "w", (UNS) tmp3, svPtr); // Store result s274

//--------------
//       If
//--------------

                    if (sym_(SYMGET, (UNS) "w", (UNS) tmp4, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                    _length((UNS) tmp5, (UNS) tmp4, (UNS) "");
                    if (strcmp((const char *) tmp5,(const char *) "0")==0)
                        strmove( (UNS) tmp6, (UNS) "1");
                    else strmove( (UNS) tmp6, (UNS) "0");
                    svPtr->tpx = 0; //Default $Test indicator
                    if (numcomp2((UNS) tmp6 )) { // Test if true
                        svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                        svPtr->tpx=tpx4; // break code: restore $test
                        longjmp(Efor4J,100);
                        }

//=================================================================================
                    svPtr->LineNumber=35; //  ... w " ",w
//=================================================================================

//--------------
//       Write
//--------------

                    if (svPtr->out_file[svPtr->io]==NULL)
                        ErrorMessage("Write to input file", svPtr->LineNumber); // m1944
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     " ");
                    if (sym_(SYMGET, (UNS) "w", (UNS) tmp0, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "w"); // not found
                    svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s",
                                                     tmp0);
                    }
                while (0);   /* dotted un-indent 2 */
                longjmp(Efor4J,99); /* return */

Do_Block_Bypass4: ; // D3607

//=================================================================================
                svPtr->LineNumber=36; //  .. read line if '$test break
//=================================================================================

//--------------
//       Read
//--------------

                if (svPtr->in_file[svPtr->io] == NULL)
                    ErrorMessage("Read from input file", svPtr->LineNumber);
                svPtr->tpx = getstr1(svPtr->in_file[svPtr->io], &gtmp); // Read string into gtmp
                if (svPtr->tpx >= 0) svPtr->tpx = 1;
                else svPtr->tpx = 0; // Set $Test
                sym_(SYMSTORE, (UNS) "line", (UNS) gtmp, svPtr); // Store result s274

//--------------
//       If
//--------------

                if (svPtr->tpx) tmp1[0]='1'; /* $test */
                else tmp1[0]='0';
                tmp1[1]='\0';
                if (numcomp1( (UNS) tmp1, 0) == 0)
                    strmove( (UNS) tmp2, (UNS) "1");
                else strmove( (UNS) tmp2, (UNS) "0");
                svPtr->tpx = 0; //Default $Test indicator
                if (numcomp2((UNS) tmp2 )) { // Test if true
                    svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                    svPtr->tpx=tpx3; // break code: restore $test
                    longjmp(Efor3J,100);
                    }

//=================================================================================
                svPtr->LineNumber=37; //  .. if line="" break
//=================================================================================

//--------------
//       If
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                if (strcmp((const char *) tmp0,(const char *) "")==0)
                    strmove( (UNS) tmp1, (UNS) "1");
                else strmove( (UNS) tmp1, (UNS) "0");
                svPtr->tpx = 0; //Default $Test indicator
                if (numcomp2((UNS) tmp1 )) { // Test if true
                    svPtr->tpx = 1; // $test becomes true

//--------------
//       Break
//--------------

                    svPtr->tpx=tpx3; // break code: restore $test
                    longjmp(Efor3J,100);
                    }

//=================================================================================
                svPtr->LineNumber=38; //  .. if $find(line,"ABSTRACT") set line=$piece(line,"ABSTRACT",1)
//=================================================================================

//--------------
//       If
//--------------

                if (sym_(SYMGET, (UNS) "line", (UNS) tmp0, svPtr) == NULL) // get value
                    VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                _find( (UNS) tmp1, (UNS) tmp0, (UNS)"ABSTRACT", (UNS) "-1");
                svPtr->tpx = 0; //Default $Test indicator
                if (numcomp2((UNS) tmp1 )) { // Test if true
                    svPtr->tpx = 1; // $test becomes true

//--------------
//       Set
//--------------

                    if (sym_(SYMGET, (UNS) "line", (UNS) tmp3, svPtr) == NULL) // get value
                        VariableNotFound1(svPtr->LineNumber, (UNS) "line"); // not found
                    _piece((UNS) tmp4,
                           (UNS) tmp3,(UNS) "ABSTRACT",(UNS) "1", (UNS) "-1",
                           0, (UNS) "", svPtr); // p1136
                    sym_(SYMSTORE, (UNS) "line", (UNS) tmp4, svPtr); // Store result s274
                    }
                }
            while(0);   // dotted un-indent 1
            longjmp(Efor3J,99); // return

Do_Block_Bypass3: ; //B848

            }
        while(0);   // dotted un-indent 0
        longjmp(Efor0J,99); // return

Do_Block_Bypass0: ; //B848


//=================================================================================
        svPtr->LineNumber=40; //  close 1
//=================================================================================

//--------------
//       Close
//--------------

        _i=atoi( CSTR "1");
        if (svPtr->in_file[_i] == NULL && svPtr->out_file[_i] == NULL)
            ErrorMessage("Attempt to close unopened file", svPtr->LineNumber);
        if (svPtr->in_file[_i]!=NULL) {
            fclose(svPtr->in_file[_i]);
            svPtr->in_file[_i]=NULL;
            }
        else {
            fclose(svPtr->out_file[_i]);
            svPtr->out_file[_i]=NULL;
            }

//=================================================================================
_epilogue:
        tmp0[0]=0;
        tmp1[0]=0;  /*  Function Epilogue */
        Mltoa(getpid(),atmp);
        if (svPtr->LockDone) cleanLocks((char *) atmp);
        Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */

        } // end of try block

    catch(...) {
        if (GlobalExceptionCode == INPUT_ERROR) cout << "Input Error" << endl;
        else if (GlobalExceptionCode == INPUT_LENGTH) cout << "Input Length Error" << endl;
        else if (GlobalExceptionCode == SYMTAB_ERROR) cout << "Symbol Table Error" << endl;
        else if (GlobalExceptionCode == GLOBAL_NOT_FOUND) cout << "Global Not Found Error" << endl;
        else if (GlobalExceptionCode == INTERPRETER_ERROR) cout << "Interprerer Error" << endl;
        else if (GlobalExceptionCode == INVALID_CONVERSION) cout << "Invalid Conversion Error" << endl;
        else if (GlobalExceptionCode == DATA_RANGE_ERROR) cout << "Data Range Error" << endl;
        else if (GlobalExceptionCode == NUMERIC_RANGE) cout << "Numeric Range Error" << endl;
        else if (GlobalExceptionCode == UNSPECIFIED) cout << "Unspecified Error" << endl;
        cout << "Uncaught error in or near line "
             << svPtr->LineNumber << endl;
        Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */
        }

    return EXIT_SUCCESS;
    }  /* Terminate */
//=================================================================================


int _label_lookup(char *label) {
    return -1;
    }
const char * _text_function(int disp) {
    return NULL;
    }

