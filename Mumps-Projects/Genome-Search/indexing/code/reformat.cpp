// ==============================================================
//#+ This module generated by Mumps Compiler @VERSION@ Apr  9 2023
//#+  
//#+ Portions of this code are part of the Mumps Compiler
//#+ 
//#+ Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 
//#+ 2010, 2017, 2020, 2022, 2023 by Kevin C. O'Kane  
//#+ 
//#+ Kevin C. O'Kane, Ph.D.
//#+ Professor Emeritus
//#+ Computer Science Department
//#+ University of Northern Iowa
//#+ Cedar Falls, IA 50614-0507
//#+ kc.okane@gmail.com
//#+ https://threadsafebooks.com
//#+ https://www.cs.uni.edu/~okane
//#+ -----------------------------------
//#+ 
//#+ Consult individual modules for copyright details
//#+ The runtime libraries are covered by the following license:
//#+  
//#+ This library is free software; you can redistribute it and/or
//#+ modify it under the terms of the GNU Lesser General Public
//#+ License as published by the Free Software Foundation; either
//#+ version 2.1 of the License, or (at your option) any later version.
//#+ 
//#+ This library is distributed in the hope that it will be useful,
//#+ but WITHOUT ANY WARRANTY; without even the implied warranty of
//#+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//#+ Lesser General Public License for more details.
//#+ 
//#+ You should have received a copy of the GNU Lesser General Public
//#+ License along with this library; if not, write to the Free Software
//#+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//#+ 
//#+ This code is unverified - use at your own risk 
//#+==============================================================

#undef _MDH_
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <sys/time.h>
#include <mumpsc/inline.h>
#include <mumpsc/defines.h>
#include <mumpsc/strmax.h>
#include <mumpsc/libmpscpp.h>
#include <mumpsc/sym.h>
#include <mumpsc/builtin.h>
#include <mumpsc/compiler.h>
#define FORPARM STR_MAX  /* Size of For loop parameter */
#define CSTR (char *)
#define USTR unsigned char *
#define CCHR const char *
#include <mumpsc/keyfix.h>
#include <mumpsc/globalOrder.h>
#include <mumpsc/stateVector.h>
int (*__label_lookup)(char *);
char * (*__text_function)(int);
void fcn(MSV *);
void zfcn(unsigned char *, unsigned char *, struct MSV *); /* z functions */
char * sym_(int, unsigned char *, unsigned char *, struct MSV *); /* symbol table */
char * makeLock(char *, char *, char *, char, char *); /* global array lock service */
char * cleanLocks(char *); /* global array lock service */
char * releaseLock(char *, char *, char *); /* global array lock service */
char * eraseLocks(char *); /* global array lock service */
void add(const char *a,const char *b,char *c); /* math function */
void sub(const char *a,const char *b,char *c); /* math function */
void mult(const char *a,const char *b,char *c); /* math function */
void divx(const char *a,const char *b,char *c); /* math function */
void divi(const char *a,const char *b,char *c); /* math function */
void _fnumber(unsigned char *,unsigned char *,
       unsigned char *,unsigned char *, MSV *); /* math function */
int DBSem = 0; /* deadlock prevention */
void SyncClock() {
    DBSem = 1;
    }
unsigned int set_alarm (unsigned int seconds) {
    struct itimerval old, xnew;
    xnew.it_interval.tv_usec = 0;
    xnew.it_interval.tv_sec = 0 ; // interval between alarms
    xnew.it_value.tv_usec = 0;
    xnew.it_value.tv_sec = (long int) 0;
    if (setitimer (ITIMER_REAL, &xnew, &old) < 0)
        return 0;
    else
        return old.it_value.tv_sec;
    }
#include <mumpsc/global.h>  /* Global array definitions */
  /* Interface to Mglobal(): */
  /* g = command */
  /* key = key sought or stored */
  /* bd = value returned or stored */
  /* svPtr = address of state vector */
#ifndef SUB
#include <mumpsc/fcns.h>  /* System support functions */
#include <mumpsc/sysfunc.h>  /* Many common global variables */
#endif
 // !/usr/bin/mumps
 //  Copyright 2014, 2022 Kevin C. O'Kane
 //  reformat.mps March 29, 2022
//================================================================================= 
//  zmain 
//================================================================================= 

int main(int argc, char *argv[]) {

//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//#+ Intermediate temporary variables used during execution of string expressions
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

char *_ftmp = new char[STR_MAX]; /* intermediate temp */
/*** Temporary variables */
char for1_incr[FORPARM],for1_lim[FORPARM],for1_init[FORPARM];
int for1F; int for1T; long for1; double for1D;
char for2_incr[FORPARM],for2_lim[FORPARM],for2_init[FORPARM];
int for2F; int for2T; long for2; double for2D;
char for3_incr[FORPARM],for3_lim[FORPARM],for3_init[FORPARM];
int for3F; int for3T; long for3; double for3D;
char for4_incr[FORPARM],for4_lim[FORPARM],for4_init[FORPARM];
int for4F; int for4T; long for4; double for4D;
char for5_incr[FORPARM],for5_lim[FORPARM],for5_init[FORPARM];
int for5F; int for5T; long for5; double for5D;
char for6_incr[FORPARM],for6_lim[FORPARM],for6_init[FORPARM];
int for6F; int for6T; long for6; double for6D;
jmp_buf for0J;
jmp_buf for1J;
jmp_buf for2J;
jmp_buf for3J;
jmp_buf for4J;
jmp_buf for5J;
jmp_buf for6J;
jmp_buf for7J;
jmp_buf Efor0J;
int tpx0;
jmp_buf Efor1J;
int tpx1;
jmp_buf Efor2J;
int tpx2;
jmp_buf Efor3J;
int tpx3;
jmp_buf Efor4J;
int tpx4;
jmp_buf Efor5J;
int tpx5;
unsigned char *tmp0 = new unsigned char[STR_MAX];
unsigned char *tmp1 = new unsigned char[STR_MAX];
unsigned char *tmp2 = new unsigned char[STR_MAX];
unsigned char *tmp3 = new unsigned char[STR_MAX];
unsigned char *tmp4 = new unsigned char[STR_MAX];
unsigned char *tmp5 = new unsigned char[STR_MAX];
unsigned char *tmp6 = new unsigned char[STR_MAX];
unsigned char *_dummy = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *atmp =new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *xgtmp = new unsigned char [STR_MAX]; /* temporary variable */
unsigned char *gtmpL = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *tmp = new unsigned char[STR_MAX]; /* temporary variable */
unsigned char *gtmp = new unsigned char [2*STR_MAX]; /* temporary variable */
int _label_lookup(char *); /* resolution of labels */
char * _text_function(int);
static unsigned char _ReturnVal[STR_MAX]; /* function returns */
int _ArgCount=0; /* Nbr of args to extrinsic */
long _i,_jj,_j,_k,_new;
int _SymPush=0,f=0;
int g=0;
jmp_buf _doStack[128]; /* <do> return stack mechanism */
short   _doStackN[128]={0}; /* <do> return stack mechanism */
static int     _doStx=0; /* <do> return stack mechanism */
char _Refs[10][32];
int _Refsx=0;

if (svPtr == NULL) svPtr = AllocSV();

_SymPush=0; // zap pushed tables 

svPtr->in_file[5]=stdin; // console default/
svPtr->out_file[5]=stdout; // console default

strcpy(svPtr->UDAT,"data.dat");
strcpy(svPtr->UKEY,"key.dat");

if ( 0) { // no alarm if slice is zero
	signal(SIGALRM, SyncClock);
	set_alarm(1);
	}

__label_lookup = _label_lookup;
__text_function = _text_function;

$SymPut("%",argv[0]); 

if (argc > 0) { 
	for (int i = 0; i < argc; i++) { 
		char t[STR_MAX]; 
		sprintf(t,"%%%d", i); 
		$SymPut(t, argv[i]); 
		} 
	} 

try { 
//================================================================================= 
svPtr->LineNumber=8; //  set M=$zgetenv("max_docs") 
//================================================================================= 
	strmove( (USTR) &gtmp[1], (USTR) "");
	strcat((char *) &gtmp[1],"$zgetenv\xce");
	strcat((char *) &gtmp[1],(char *) "max_docs");
	strcat((char *) &gtmp[1],"\xcf");
	zfcn(gtmp,tmp1,svPtr);
	sym_(0, (USTR) "M", (USTR) tmp1, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=9; //  if M="" set M=1000000 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "M", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "M");
	if (strcmp((const char *) tmp0,(const char *) "")==0) 
	strmove( (USTR) tmp1, (USTR) "1");
	else strmove( (USTR) tmp1, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp1, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	sym_(0, (USTR) "M", (USTR) "1000000", svPtr); // Store result 
	} 
//================================================================================= 
svPtr->LineNumber=10; //  open 1:"titles.list,new" 
//================================================================================= 
	_i=atoi( CSTR "1");
	strmove((USTR) tmp0, (USTR) "titles.list,new");
	for(_j=0; tmp0[_j]!=0 && tmp0[_j]!=',';_j++);
	if (tmp0[_j]!=',') ErrorMessage("File open error",svPtr->LineNumber);
	tmp0[_j++]=0;
	strmove((USTR) gtmp, (USTR) tmp0);
	if (strcmp( (CCHR) &tmp0[_j], (CCHR) "old") == 0 || 
		strcmp( (CCHR) &tmp0[_j], (CCHR) "OLD") == 0) _new = 0; 
	else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "new") == 0 || 
		strcmp((CCHR) &tmp0[_j], (CCHR) "NEW") == 0) _new = 1; 
	else if (strcmp( (CCHR) &tmp0[_j], (CCHR) "append") == 0 || 
		strcmp( (CCHR) &tmp0[_j], (const char *) "APPEND") == 0) _new=2; 
	else ErrorMessage("File open error",svPtr->LineNumber);
	if (svPtr->out_file[_i] != NULL || svPtr->in_file[_i] != NULL) 
		ErrorMessage("File already open", svPtr->LineNumber); 
	if (_new==1) { /* output */ 
		svPtr->out_file[_i] = fopen((const char *) gtmp, "w"); 
		if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0; 
		else svPtr->tpx = 1; 
		} 
	else if (_new == 2) { /* append */ 
		svPtr->out_file[_i] = fopen((const char *) gtmp, "a"); 
		if(svPtr->out_file[_i] == NULL) svPtr->tpx = 0; 
		else svPtr->tpx = 1; 
		} 
	else { /* input */ 
		svPtr->in_file[_i] = fopen((const char *) gtmp, "r"); 
		if(svPtr->in_file[_i] == NULL) svPtr->tpx = 0; 
		else svPtr->tpx = 1; 
		}
//================================================================================= 
svPtr->LineNumber=11; //  kill ^map 
//================================================================================= 
	strmove( (USTR) gtmp, (USTR) "");
	strcat((char *) gtmp,(char *) "^map"); 
	{ 
	unsigned char tmp14[STR_MAX], tmp15[STR_MAX]; 
	keyfix(gtmp);
	_k = strlen((const char *) gtmp); 
	strmove((USTR) tmp14, (USTR) gtmp); 
	Mglobal(GKILL, gtmp, tmp15, svPtr); 
	while(1) { 
		_j = Mglobal(XNEXT, gtmp, tmp15, svPtr); 
		if (_j && strncmp( (CCHR) tmp14, (CCHR) gtmp,_k) == 0) { 
			Mglobal(GKILL, gtmp, tmp15, svPtr); 
			continue; 
			} 
		break; 
		} 
	}
//================================================================================= 
svPtr->LineNumber=13; //  set D=0 
//================================================================================= 
	sym_(0, (USTR) "D", (USTR) "0", svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=15; //  for  do  if D>M quit 
//================================================================================= 
	while(1) {  /* Argumentless FOR */
		tpx0=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor0J)==0) goto Do_Block_Entry0; //else continue 
		svPtr->tpx=tpx0; svPtr->_Sym--;// return from argumentless do 
	if (sym_(SYMGET, (USTR) "D", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "D");
	if (sym_(SYMGET, (USTR) "M", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "M");
	if (numcomp((USTR) tmp0, (USTR) tmp1) > 0) strmove((USTR) tmp2, (USTR) "1");
	else strmove((USTR) tmp2, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp2, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	break; 
	} // if block 
	} 
	goto Do_Block_Bypass0; // C3551 bypass indented group

Do_Block_Entry0:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=16; //  . set o=$ztell read line if '$test break 
//================================================================================= 
	strcpy((char *) &gtmp[1],(const char *) "$ztell");
	zfcn(gtmp,tmp1,svPtr);
	sym_(0, (USTR) "o", (USTR) tmp1, svPtr); // Store result 
	if (svPtr->in_file[svPtr->io] == NULL) 
		ErrorMessage("Read from input file", svPtr->LineNumber); 
	svPtr->tpx=getstr1(svPtr->in_file[svPtr->io],&gtmp); // Read string into gtmp
	if (svPtr->tpx>=0) svPtr->tpx=1; else svPtr->tpx=0; // Set $Test
	sym_(0, (USTR) "line", (USTR) gtmp, svPtr); // Store result 
	if (svPtr->tpx) tmp3[0]='1'; /* $test */
	else tmp3[0]='0';
	tmp3[1]='\0';
	if (numcomp1( (USTR) tmp3, 0)==0) 
		strmove( (USTR) tmp4, (USTR) "1");
	else strmove( (USTR) tmp4, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp4, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	svPtr->tpx=tpx0; // break code: restore $test
	svPtr->_Sym--; // restore sym stack
	goto Do_Block_Bypass0; // break code
	}
//================================================================================= 
svPtr->LineNumber=17; //  . if $extract(line,1,2)="TI" do  quit 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp1, (unsigned char *) tmp0,(unsigned char *) "1",(unsigned char *) "2"); 
	if (strcmp((const char *) tmp1,(const char *) "TI")==0) 
	strmove( (USTR) tmp2, (USTR) "1");
	else strmove( (USTR) tmp2, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp2, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
		tpx1=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor1J)==0) goto Do_Block_Entry1; //else continue 
		svPtr->tpx=tpx1; svPtr->_Sym--;// return from argumentless do 
	break; 
	} // if block 
	goto Do_Block_Bypass1; // C3551 bypass indented group

Do_Block_Entry1:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=18; //  .. set D=D+1 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "D", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "D");
	add( (char *) tmp1, "1", (char *) tmp2 ); 
	sym_(0, (USTR) "D", (USTR) tmp2, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=19; //  .. use 1 write D," ",$extract(line,7,200),! use 5 
//================================================================================= 
	svPtr->io=atoi( CSTR "1");
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	if (sym_(SYMGET, (USTR) "D", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "D");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp2, (unsigned char *) tmp1,(unsigned char *) "7",(unsigned char *) "200"); 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp2);
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	svPtr->io=atoi( CSTR "5");
//================================================================================= 
svPtr->LineNumber=20; //  .. write off," ",D 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	if (sym_(SYMGET, (USTR) "off", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "off");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
	if (sym_(SYMGET, (USTR) "D", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "D");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp1);
//================================================================================= 
svPtr->LineNumber=21; //  .. set ^map(D)=off 
//================================================================================= 
	strmove((USTR) tmp1, (USTR) "^map\xce"); // M3701
	if (sym_(SYMGET, (USTR) "D", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "D");
	strcat((char *) tmp1,(char *) tmp0); // a
	strcat((char *) tmp1,(char *) "\xcf");

	{ 
	unsigned char seg[STR_MAX]; 
	if (sym_(SYMGET, (USTR) "off", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "off");
	strcpy(seg, tmp2); 
	f = Mglobal(STORE, tmp1, seg, svPtr); 
	} 

//================================================================================= 
svPtr->LineNumber=22; //  .. set line=$zlower($e(line,7,2048)) 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp2, (unsigned char *) tmp1,(unsigned char *) "7",(unsigned char *) "2048"); 
	strmove( (USTR) &gtmp[1], (USTR) "");
	strcat((char *) &gtmp[1],"$zlower\xce");
	strcat((char *) &gtmp[1],(char *) tmp2);
	strcat((char *) &gtmp[1],"\xcf");
	zfcn(gtmp,tmp3,svPtr);
	sym_(0, (USTR) "line", (USTR) tmp3, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=23; //  .. set line=$zblanks(line) 
//================================================================================= 
	strmove( (USTR) &gtmp[1], (USTR) "");
	strcat((char *) &gtmp[1],"$zblanks\xce");
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	strcat((char *) &gtmp[1],(char *) tmp1);
	strcat((char *) &gtmp[1],"\xcf");
	zfcn(gtmp,tmp2,svPtr);
	sym_(0, (USTR) "line", (USTR) tmp2, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=24; //  .. for i=1:1 do 
//================================================================================= 
	strmove((USTR) for3_init, (USTR) "1");
	strmove( (USTR) for3_incr, (USTR) "1");
	if (strchr((char *) for3_incr,'.')) { 
		for3D=atof(for3_incr);
		for3F=for3D<0.0 ? 1 : 0;
		for3T=1;
		}
	else { 
		for3=atol(for3_incr); 
		for3F=for3<0 ? 1 : 0;
		for3T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for3_init, svPtr); // init loop variable

1;  /* limit expression - no limit */
	for3T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for3D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for3, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for3J)==0) goto For3; // else continue

	goto For3Exit; // bypass block 

For3: // for loop entry point

	do { 
	svPtr->LineNumber=24; 
		tpx2=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor2J)==0) goto Do_Block_Entry2; //else continue 
		svPtr->tpx=tpx2; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for3J,99); // FOR loop 1 close 

For3Exit: ; // exit for loop 

	goto Do_Block_Bypass2; // C3551 bypass indented group

Do_Block_Entry2:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=25; //  ... s w=$p(line," ",i) if $l(w)=0 break 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	_piece((USTR) tmp3, 
		(USTR) tmp1,(USTR) " ",(USTR) tmp2, (USTR) "-1", 
		0, (USTR) "", svPtr); 
	sym_(0, (USTR) "w", (USTR) tmp3, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "w", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "w");
	_length((USTR) tmp5, (USTR)tmp4, (USTR) "");
	if (strcmp((const char *) tmp5,(const char *) "0")==0) 
	strmove( (USTR) tmp6, (USTR) "1");
	else strmove( (USTR) tmp6, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp6, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	svPtr->tpx=tpx2; // break code: restore $test
	svPtr->_Sym--; // restore sym stack
	goto Do_Block_Bypass2; // break code
	}
//================================================================================= 
svPtr->LineNumber=26; //  ... w " ",w 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
	if (sym_(SYMGET, (USTR) "w", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "w");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	} while (0); /* dotted un-indent 2 */
	longjmp(Efor2J,99); /* return */

Do_Block_Bypass2: ; // D3607 
	} while (0); /* dotted un-indent 1 */
	longjmp(Efor1J,99); /* return */

Do_Block_Bypass1: ; // D3607 
//================================================================================= 
svPtr->LineNumber=27; //  . if $extract(line,1,2)="MH" quit 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp1, (unsigned char *) tmp0,(unsigned char *) "1",(unsigned char *) "2"); 
	if (strcmp((const char *) tmp1,(const char *) "MH")==0) 
	strmove( (USTR) tmp2, (USTR) "1");
	else strmove( (USTR) tmp2, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp2, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	break; 
	} // if block 
//================================================================================= 
svPtr->LineNumber=28; //  . if $extract(line,1,13)="STAT- MEDLINE" set off=o write:D'=0 ! quit 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp1, (unsigned char *) tmp0,(unsigned char *) "1",(unsigned char *) "13"); 
	if (strcmp((const char *) tmp1,(const char *) "STAT- MEDLINE")==0) 
	strmove( (USTR) tmp2, (USTR) "1");
	else strmove( (USTR) tmp2, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp2, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	if (sym_(SYMGET, (USTR) "o", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "o");
	sym_(0, (USTR) "off", (USTR) tmp4, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "D", (USTR) tmp5, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "D");
	if (strcmp((const char *) tmp5, (const char *) "0") != 0)
		strmove((USTR) tmp6, (USTR) "1");
	else strmove((USTR) tmp6, (USTR) "0");
	if (atoi( CSTR tmp6)) { /* postconditional */
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	fprintf(svPtr->out_file[svPtr->io], "\n"); 
	svPtr->hor[svPtr->io]=0; svPtr->ver[svPtr->io]++; 
	} /* post conditional */
	break; 
	} // if block 
//================================================================================= 
svPtr->LineNumber=29; //  . if $extract(line,1,2)'="AB" quit 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp1, (unsigned char *) tmp0,(unsigned char *) "1",(unsigned char *) "2"); 
	if (strcmp((const char *) tmp1, (const char *) "AB") != 0)
		strmove((USTR) tmp2, (USTR) "1");
	else strmove((USTR) tmp2, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp2, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	break; 
	} // if block 
//================================================================================= 
svPtr->LineNumber=30; //  . for  do 
//================================================================================= 
	while(1) {  /* Argumentless FOR */
		tpx3=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor3J)==0) goto Do_Block_Entry3; //else continue 
		svPtr->tpx=tpx3; svPtr->_Sym--;// return from argumentless do 
	} 
	goto Do_Block_Bypass3; // C3551 bypass indented group

Do_Block_Entry3:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=31; //  .. set line=$zlower($e(line,7,2048)) 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_extract( (unsigned char *) tmp2, (unsigned char *) tmp1,(unsigned char *) "7",(unsigned char *) "2048"); 
	strmove( (USTR) &gtmp[1], (USTR) "");
	strcat((char *) &gtmp[1],"$zlower\xce");
	strcat((char *) &gtmp[1],(char *) tmp2);
	strcat((char *) &gtmp[1],"\xcf");
	zfcn(gtmp,tmp3,svPtr);
	sym_(0, (USTR) "line", (USTR) tmp3, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=32; //  .. set line=$zblanks(line) 
//================================================================================= 
	strmove( (USTR) &gtmp[1], (USTR) "");
	strcat((char *) &gtmp[1],"$zblanks\xce");
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	strcat((char *) &gtmp[1],(char *) tmp1);
	strcat((char *) &gtmp[1],"\xcf");
	zfcn(gtmp,tmp2,svPtr);
	sym_(0, (USTR) "line", (USTR) tmp2, svPtr); // Store result 
//================================================================================= 
svPtr->LineNumber=33; //  .. for i=1:1 do 
//================================================================================= 
	strmove((USTR) for6_init, (USTR) "1");
	strmove( (USTR) for6_incr, (USTR) "1");
	if (strchr((char *) for6_incr,'.')) { 
		for6D=atof(for6_incr);
		for6F=for6D<0.0 ? 1 : 0;
		for6T=1;
		}
	else { 
		for6=atol(for6_incr); 
		for6F=for6<0 ? 1 : 0;
		for6T=0;
		} /* increment */

	for ( sym_(0, (USTR) "i", (USTR) for6_init, svPtr); // init loop variable

1;  /* limit expression - no limit */
	for6T ? /* increment */
	add3( sym_(11, (USTR) "i", _dummy, svPtr), for6D, (char *) _dummy),
	sym_(0,(USTR) "i",(USTR) _dummy,svPtr)
	: 
	add1( (const char *) sym_(11, (USTR) "i", _dummy, svPtr), for6, (char *) _dummy),
	sym_(0,(USTR) "i", _dummy,svPtr))

	if (setjmp(for6J)==0) goto For6; // else continue

	goto For6Exit; // bypass block 

For6: // for loop entry point

	do { 
	svPtr->LineNumber=33; 
		tpx4=svPtr->tpx; 
		svPtr->_Sym++;
		if (setjmp(Efor4J)==0) goto Do_Block_Entry4; //else continue 
		svPtr->tpx=tpx4; svPtr->_Sym--;// return from argumentless do 
	} while (0); longjmp(for6J,99); // FOR loop 1 close 

For6Exit: ; // exit for loop 

	goto Do_Block_Bypass4; // C3551 bypass indented group

Do_Block_Entry4:; // Enter Do Block

do { /* dotted indent entry */
//================================================================================= 
svPtr->LineNumber=34; //  ... set w=$p(line," ",i) if $l(w)=0 break 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp1, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	if (sym_(SYMGET, (USTR) "i", (USTR) tmp2, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "i");
	_piece((USTR) tmp3, 
		(USTR) tmp1,(USTR) " ",(USTR) tmp2, (USTR) "-1", 
		0, (USTR) "", svPtr); 
	sym_(0, (USTR) "w", (USTR) tmp3, svPtr); // Store result 
	if (sym_(SYMGET, (USTR) "w", (USTR) tmp4, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "w");
	_length((USTR) tmp5, (USTR)tmp4, (USTR) "");
	if (strcmp((const char *) tmp5,(const char *) "0")==0) 
	strmove( (USTR) tmp6, (USTR) "1");
	else strmove( (USTR) tmp6, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp6, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	svPtr->tpx=tpx4; // break code: restore $test
	svPtr->_Sym--; // restore sym stack
	goto Do_Block_Bypass4; // break code
	}
//================================================================================= 
svPtr->LineNumber=35; //  ... w " ",w 
//================================================================================= 
	if (svPtr->out_file[svPtr->io]==NULL) 
		ErrorMessage("Write to input file", svPtr->LineNumber); // W1001 
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		" ");
	if (sym_(SYMGET, (USTR) "w", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "w");
	svPtr->hor[svPtr->io] += fprintf(svPtr->out_file[svPtr->io], "%s", 
		tmp0);
	} while (0); /* dotted un-indent 2 */
	longjmp(Efor4J,99); /* return */

Do_Block_Bypass4: ; // D3607 
//================================================================================= 
svPtr->LineNumber=36; //  .. read line if '$test break 
//================================================================================= 
	if (svPtr->in_file[svPtr->io] == NULL) 
		ErrorMessage("Read from input file", svPtr->LineNumber); 
	svPtr->tpx=getstr1(svPtr->in_file[svPtr->io],&gtmp); // Read string into gtmp
	if (svPtr->tpx>=0) svPtr->tpx=1; else svPtr->tpx=0; // Set $Test
	sym_(0, (USTR) "line", (USTR) gtmp, svPtr); // Store result 
	if (svPtr->tpx) tmp1[0]='1'; /* $test */
	else tmp1[0]='0';
	tmp1[1]='\0';
	if (numcomp1( (USTR) tmp1, 0)==0) 
		strmove( (USTR) tmp2, (USTR) "1");
	else strmove( (USTR) tmp2, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp2, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	svPtr->tpx=tpx3; // break code: restore $test
	svPtr->_Sym--; // restore sym stack
	goto Do_Block_Bypass3; // break code
	}
//================================================================================= 
svPtr->LineNumber=37; //  .. if line="" break 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	if (strcmp((const char *) tmp0,(const char *) "")==0) 
	strmove( (USTR) tmp1, (USTR) "1");
	else strmove( (USTR) tmp1, (USTR) "0");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp1, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	svPtr->tpx=tpx3; // break code: restore $test
	svPtr->_Sym--; // restore sym stack
	goto Do_Block_Bypass3; // break code
	}
//================================================================================= 
svPtr->LineNumber=38; //  .. if $find(line,"ABSTRACT") set line=$piece(line,"ABSTRACT",1) 
//================================================================================= 
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp0, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_find( (USTR) tmp1, (USTR) tmp0, (USTR)"ABSTRACT", (USTR) "-1");
	svPtr->tpx = 0; //Default $Test indicator
	if (numcomp((USTR) tmp1, (USTR) "0")) { // Test if true 
	svPtr->tpx = 1; // $test becomes true
	if (sym_(SYMGET, (USTR) "line", (USTR) tmp3, svPtr) == NULL) 
		VariableNotFound1(svPtr->LineNumber, (USTR) "line");
	_piece((USTR) tmp4, 
		(USTR) tmp3,(USTR) "ABSTRACT",(USTR) "1", (USTR) "-1", 
		0, (USTR) "", svPtr); 
	sym_(0, (USTR) "line", (USTR) tmp4, svPtr); // Store result 
	} 
	} while(0); // dotted un-indent 1 
	longjmp(Efor3J,99); // return 

Do_Block_Bypass3: ; //B848 

	} while(0); // dotted un-indent 0 
	longjmp(Efor0J,99); // return 

Do_Block_Bypass0: ; //B848 

//================================================================================= 
svPtr->LineNumber=40; //  close 1 
//================================================================================= 
	_i=atoi( CSTR "1");
	if (svPtr->in_file[_i] == NULL && svPtr->out_file[_i] == NULL) 
		ErrorMessage("Attempt to close unopened file", svPtr->LineNumber); 
	if (svPtr->in_file[_i]!=NULL) { 
	fclose(svPtr->in_file[_i]); svPtr->in_file[_i]=NULL; }
	else { fclose(svPtr->out_file[_i]); svPtr->out_file[_i]=NULL; }

//=================================================================================
_epilogue: tmp0[0]=0; tmp1[0]=0;  /*  Function Epilogue */
	Mltoa(getpid(),atmp);
	if (svPtr->LockDone) cleanLocks((char *) atmp);
	Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */

} // end of try block 

catch(...) { 
     if (GlobalExceptionCode == INPUT_ERROR) cout << "Input Error" << endl;
     else if (GlobalExceptionCode == INPUT_LENGTH) cout << "Input Length Error" << endl;
     else if (GlobalExceptionCode == SYMTAB_ERROR) cout << "Symbol Table Error" << endl;
     else if (GlobalExceptionCode == GLOBAL_NOT_FOUND) cout << "Global Not Found Error" << endl;
     else if (GlobalExceptionCode == INTERPRETER_ERROR) cout << "Interprerer Error" << endl;
     else if (GlobalExceptionCode == INVALID_CONVERSION) cout << "Invalid Conversion Error" << endl;
     else if (GlobalExceptionCode == DATA_RANGE_ERROR) cout << "Data Range Error" << endl;
     else if (GlobalExceptionCode == NUMERIC_RANGE) cout << "Numeric Range Error" << endl;
     else if (GlobalExceptionCode == UNSPECIFIED) cout << "Unspecified Error" << endl;
	cout << "Uncaught error in or near line " 
	<< svPtr->LineNumber << endl;
	Mglobal(CLOSE,tmp0,tmp1,svPtr);  /* Close Globals */
	} 

return EXIT_SUCCESS; }  /* Terminate */
//=================================================================================


int _label_lookup(char *label) { return -1; }
char * _text_function(int disp) { return NULL; }

